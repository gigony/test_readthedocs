
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>monai.transforms.spatial.dictionary &#8212; MONAI 0.6.0 Documentation</title>
    
  <link href="../../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/MONAI-logo-color.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../whatsnew.html">
  Whatâ€™s New
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../highlights.html">
  Modules Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../installation.html">
  Installation Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../contrib.html">
  Development
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/Project-MONAI/tutorials">Tutorials<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/project-monai/monai" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/projectmonai" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for monai.transforms.spatial.dictionary</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020 - 2021 MONAI Consortium</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A collection of dictionary-based wrappers around the &quot;vanilla&quot; transforms for spatial operations</span>
<span class="sd">defined in :py:class:`monai.transforms.spatial.array`.</span>

<span class="sd">Class names are ended with &#39;d&#39; to denote dictionary-based transforms.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">monai.config</span> <span class="kn">import</span> <span class="n">DtypeLike</span><span class="p">,</span> <span class="n">KeysCollection</span>
<span class="kn">from</span> <span class="nn">monai.networks.layers</span> <span class="kn">import</span> <span class="n">AffineTransform</span>
<span class="kn">from</span> <span class="nn">monai.networks.layers.simplelayers</span> <span class="kn">import</span> <span class="n">GaussianFilter</span>
<span class="kn">from</span> <span class="nn">monai.transforms.croppad.array</span> <span class="kn">import</span> <span class="n">CenterSpatialCrop</span><span class="p">,</span> <span class="n">SpatialPad</span>
<span class="kn">from</span> <span class="nn">monai.transforms.inverse</span> <span class="kn">import</span> <span class="n">InvertibleTransform</span>
<span class="kn">from</span> <span class="nn">monai.transforms.spatial.array</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AddCoordinateChannels</span><span class="p">,</span>
    <span class="n">Affine</span><span class="p">,</span>
    <span class="n">AffineGrid</span><span class="p">,</span>
    <span class="n">Flip</span><span class="p">,</span>
    <span class="n">Orientation</span><span class="p">,</span>
    <span class="n">Rand2DElastic</span><span class="p">,</span>
    <span class="n">Rand3DElastic</span><span class="p">,</span>
    <span class="n">RandAffine</span><span class="p">,</span>
    <span class="n">Resize</span><span class="p">,</span>
    <span class="n">Rotate</span><span class="p">,</span>
    <span class="n">Rotate90</span><span class="p">,</span>
    <span class="n">Spacing</span><span class="p">,</span>
    <span class="n">Zoom</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">monai.transforms.transform</span> <span class="kn">import</span> <span class="n">MapTransform</span><span class="p">,</span> <span class="n">RandomizableTransform</span>
<span class="kn">from</span> <span class="nn">monai.transforms.utils</span> <span class="kn">import</span> <span class="n">create_grid</span>
<span class="kn">from</span> <span class="nn">monai.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GridSampleMode</span><span class="p">,</span>
    <span class="n">GridSamplePadMode</span><span class="p">,</span>
    <span class="n">InterpolateMode</span><span class="p">,</span>
    <span class="n">NumpyPadMode</span><span class="p">,</span>
    <span class="n">ensure_tuple</span><span class="p">,</span>
    <span class="n">ensure_tuple_rep</span><span class="p">,</span>
    <span class="n">fall_back_tuple</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">monai.utils.enums</span> <span class="kn">import</span> <span class="n">InverseKeys</span>
<span class="kn">from</span> <span class="nn">monai.utils.module</span> <span class="kn">import</span> <span class="n">optional_import</span>

<span class="n">nib</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;nibabel&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Spacingd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Orientationd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rotate90d&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotate90d&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Resized&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Affined&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAffined&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand2DElasticd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand3DElasticd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Flipd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandFlipd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAxisFlipd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rotated&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotated&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Zoomd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandZoomd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SpacingD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SpacingDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OrientationD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OrientationDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rotate90D&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rotate90Dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotate90D&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotate90Dict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ResizeD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ResizeDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AffineD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AffineDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAffineD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAffineDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand2DElasticD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand2DElasticDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand3DElasticD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand3DElasticDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FlipD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FlipDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandFlipD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandFlipDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAxisFlipD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAxisFlipDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RotateD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RotateDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotateD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotateDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ZoomD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ZoomDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandZoomD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandZoomDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AddCoordinateChannelsD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AddCoordinateChannelsDict&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">InterpolateModeSequence</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">NumpyPadModeSequence</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">NumpyPadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">NumpyPadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>


<div class="viewcode-block" id="Spacingd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Spacingd">[docs]</a><span class="k">class</span> <span class="nc">Spacingd</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Spacing`.</span>

<span class="sd">    This transform assumes the ``data`` dictionary has a key for the input</span>
<span class="sd">    data&#39;s metadata and contains `affine` field.  The key is formed by ``key_{meta_key_postfix}``.</span>

<span class="sd">    After resampling the input array, this transform will write the new affine</span>
<span class="sd">    to the `affine` field of metadata which is formed by ``key_{meta_key_postfix}``.</span>

<span class="sd">    see also:</span>
<span class="sd">        :py:class:`monai.transforms.Spacing`</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spacingd.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Spacingd.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">pixdim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">diagonal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">BORDER</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">DtypeLike</span><span class="p">],</span> <span class="n">DtypeLike</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">meta_keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">KeysCollection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">meta_key_postfix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_dict&quot;</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            pixdim: output voxel spacing. if providing a single number, will use it for the first dimension.</span>
<span class="sd">                items of the pixdim sequence map to the spatial dimensions of input image, if length</span>
<span class="sd">                of pixdim sequence is longer than image spatial dimensions, will ignore the longer part,</span>
<span class="sd">                if shorter, will pad with `1.0`.</span>
<span class="sd">                if the components of the `pixdim` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of the origial pixdim, which is computed from the `affine`</span>
<span class="sd">                matrix of input image.</span>
<span class="sd">            diagonal: whether to resample the input to have a diagonal affine matrix.</span>
<span class="sd">                If True, the input data is resampled to the following affine::</span>

<span class="sd">                    np.diag((pixdim_0, pixdim_1, pixdim_2, 1))</span>

<span class="sd">                This effectively resets the volume to the world coordinate system (RAS+ in nibabel).</span>
<span class="sd">                The original orientation, rotation, shearing are not preserved.</span>

<span class="sd">                If False, the axes orientation, orthogonal rotation and</span>
<span class="sd">                translations components from the original affine will be</span>
<span class="sd">                preserved in the target affine. This option will not flip/swap</span>
<span class="sd">                axes against the original ones.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;border&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            align_corners: Geometrically, we consider the pixels of the input as squares rather than points.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of bool, each element corresponds to a key in ``keys``.</span>
<span class="sd">            dtype: data type for resampling computation. Defaults to ``np.float64`` for best precision.</span>
<span class="sd">                If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">                the output data type is always ``np.float32``.</span>
<span class="sd">                It also can be a sequence of dtypes, each element corresponds to a key in ``keys``.</span>
<span class="sd">            meta_keys: explicitly indicate the key of the corresponding meta data dictionary.</span>
<span class="sd">                for example, for data with key `image`, the metadata by default is in `image_meta_dict`.</span>
<span class="sd">                the meta data is a dictionary object which contains: filename, affine, original_shape, etc.</span>
<span class="sd">                it can be a sequence of string, map to the `keys`.</span>
<span class="sd">                if None, will try to construct meta_keys by `key_{meta_key_postfix}`.</span>
<span class="sd">            meta_key_postfix: if meta_keys=None, use `key_{postfix}` to to fetch the meta data according</span>
<span class="sd">                to the key data, default is `meta_dict`, the meta data is a dictionary object.</span>
<span class="sd">                For example, to handle key `image`,  read/write affine matrices from the</span>
<span class="sd">                metadata `image_meta_dict` dictionary&#39;s `affine` field.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: When ``meta_key_postfix`` is not a ``str``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacing_transform</span> <span class="o">=</span> <span class="n">Spacing</span><span class="p">(</span><span class="n">pixdim</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="n">diagonal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_keys</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span> <span class="k">if</span> <span class="n">meta_keys</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">meta_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;meta_keys should have the same length as keys.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_key_postfix</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">meta_key_postfix</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="Spacingd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Spacingd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
        <span class="n">d</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_key_postfix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_key_postfix</span>
        <span class="p">):</span>
            <span class="n">meta_key</span> <span class="o">=</span> <span class="n">meta_key</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">meta_key_postfix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># create metadata if necessary</span>
            <span class="k">if</span> <span class="n">meta_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;affine&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="n">meta_data</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span>
            <span class="c1"># resample array of each corresponding key</span>
            <span class="c1"># using affine fetched from d[affine_key]</span>
            <span class="n">original_spatial_shape</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">old_affine</span><span class="p">,</span> <span class="n">new_affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing_transform</span><span class="p">(</span>
                <span class="n">data_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span>
                <span class="n">affine</span><span class="o">=</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">],</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;meta_key&quot;</span><span class="p">:</span> <span class="n">meta_key</span><span class="p">,</span>
                    <span class="s2">&quot;old_affine&quot;</span><span class="p">:</span> <span class="n">old_affine</span><span class="p">,</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;padding_mode&quot;</span><span class="p">:</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">padding_mode</span><span class="p">,</span>
                    <span class="s2">&quot;align_corners&quot;</span><span class="p">:</span> <span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">orig_size</span><span class="o">=</span><span class="n">original_spatial_shape</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># set the &#39;affine&#39; key</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_affine</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Spacingd.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Spacingd.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing_transform</span><span class="o">.</span><span class="n">diagonal</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Spacingd:inverse not yet implemented for diagonal=True. &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Please raise a github issue if you need this feature&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Create inverse transform</span>
            <span class="n">meta_data</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;meta_key&quot;</span><span class="p">]]</span>
            <span class="n">old_affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;old_affine&quot;</span><span class="p">])</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
            <span class="n">padding_mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;padding_mode&quot;</span><span class="p">]</span>
            <span class="n">align_corners</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span>
            <span class="n">orig_size</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">]</span>
            <span class="n">orig_pixdim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">old_affine</span><span class="p">),</span> <span class="mi">0</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">Spacing</span><span class="p">(</span><span class="n">orig_pixdim</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing_transform</span><span class="o">.</span><span class="n">diagonal</span><span class="p">)</span>
            <span class="c1"># Apply inverse</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_affine</span> <span class="o">=</span> <span class="n">inverse_transform</span><span class="p">(</span>
                <span class="n">data_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span>
                <span class="n">affine</span><span class="o">=</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">],</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">output_spatial_shape</span><span class="o">=</span><span class="n">orig_size</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_affine</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Orientationd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Orientationd">[docs]</a><span class="k">class</span> <span class="nc">Orientationd</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Orientation`.</span>

<span class="sd">    This transform assumes the ``data`` dictionary has a key for the input</span>
<span class="sd">    data&#39;s metadata and contains `affine` field.  The key is formed by ``key_{meta_key_postfix}``.</span>

<span class="sd">    After reorienting the input array, this transform will write the new affine</span>
<span class="sd">    to the `affine` field of metadata which is formed by ``key_{meta_key_postfix}``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Orientationd.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Orientationd.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">axcodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_closest_canonical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="s2">&quot;LPI&quot;</span><span class="p">,</span> <span class="s2">&quot;RAS&quot;</span><span class="p">)),</span>
        <span class="n">meta_keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">KeysCollection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">meta_key_postfix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_dict&quot;</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            axcodes: N elements sequence for spatial ND input&#39;s orientation.</span>
<span class="sd">                e.g. axcodes=&#39;RAS&#39; represents 3D orientation:</span>
<span class="sd">                (Left, Right), (Posterior, Anterior), (Inferior, Superior).</span>
<span class="sd">                default orientation labels options are: &#39;L&#39; and &#39;R&#39; for the first dimension,</span>
<span class="sd">                &#39;P&#39; and &#39;A&#39; for the second, &#39;I&#39; and &#39;S&#39; for the third.</span>
<span class="sd">            as_closest_canonical: if True, load the image as closest to canonical axis format.</span>
<span class="sd">            labels: optional, None or sequence of (2,) sequences</span>
<span class="sd">                (2,) sequences are labels for (beginning, end) of output axis.</span>
<span class="sd">                Defaults to ``((&#39;L&#39;, &#39;R&#39;), (&#39;P&#39;, &#39;A&#39;), (&#39;I&#39;, &#39;S&#39;))``.</span>
<span class="sd">            meta_keys: explicitly indicate the key of the corresponding meta data dictionary.</span>
<span class="sd">                for example, for data with key `image`, the metadata by default is in `image_meta_dict`.</span>
<span class="sd">                the meta data is a dictionary object which contains: filename, affine, original_shape, etc.</span>
<span class="sd">                it can be a sequence of string, map to the `keys`.</span>
<span class="sd">                if None, will try to construct meta_keys by `key_{meta_key_postfix}`.</span>
<span class="sd">            meta_key_postfix: if meta_keys is None, use `key_{postfix}` to to fetch the meta data according</span>
<span class="sd">                to the key data, default is `meta_dict`, the meta data is a dictionary object.</span>
<span class="sd">                For example, to handle key `image`,  read/write affine matrices from the</span>
<span class="sd">                metadata `image_meta_dict` dictionary&#39;s `affine` field.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: When ``meta_key_postfix`` is not a ``str``.</span>

<span class="sd">        See Also:</span>
<span class="sd">            `nibabel.orientations.ornt2axcodes`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ornt_transform</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span><span class="n">axcodes</span><span class="o">=</span><span class="n">axcodes</span><span class="p">,</span> <span class="n">as_closest_canonical</span><span class="o">=</span><span class="n">as_closest_canonical</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meta_key_postfix</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;meta_key_postfix must be a str but is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">meta_key_postfix</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_keys</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span> <span class="k">if</span> <span class="n">meta_keys</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">meta_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;meta_keys should have the same length as keys.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_key_postfix</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">meta_key_postfix</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="Orientationd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Orientationd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
        <span class="n">d</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">meta_key</span><span class="p">,</span> <span class="n">meta_key_postfix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_key_postfix</span><span class="p">):</span>
            <span class="n">meta_key</span> <span class="o">=</span> <span class="n">meta_key</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">meta_key_postfix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># create metadata if necessary</span>
            <span class="k">if</span> <span class="n">meta_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;affine&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="n">meta_data</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">meta_key</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">old_affine</span><span class="p">,</span> <span class="n">new_affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ornt_transform</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">affine</span><span class="o">=</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;meta_key&quot;</span><span class="p">:</span> <span class="n">meta_key</span><span class="p">,</span> <span class="s2">&quot;old_affine&quot;</span><span class="p">:</span> <span class="n">old_affine</span><span class="p">})</span>
            <span class="n">d</span><span class="p">[</span><span class="n">meta_key</span><span class="p">][</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_affine</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Orientationd.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Orientationd.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Create inverse transform</span>
            <span class="n">meta_data</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;meta_key&quot;</span><span class="p">]]</span>
            <span class="n">orig_affine</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;old_affine&quot;</span><span class="p">]</span>
            <span class="n">orig_axcodes</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">aff2axcodes</span><span class="p">(</span><span class="n">orig_affine</span><span class="p">)</span>
            <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">Orientation</span><span class="p">(</span>
                <span class="n">axcodes</span><span class="o">=</span><span class="n">orig_axcodes</span><span class="p">,</span>
                <span class="n">as_closest_canonical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ornt_transform</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Apply inverse</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_affine</span> <span class="o">=</span> <span class="n">inverse_transform</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">affine</span><span class="o">=</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">])</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_affine</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Rotate90d"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate90d">[docs]</a><span class="k">class</span> <span class="nc">Rotate90d</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Rotate90`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Rotate90d.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate90d.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spatial_axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            k: number of times to rotate by 90 degrees.</span>
<span class="sd">            spatial_axes: 2 int numbers, defines the plane to rotate with 2 spatial axes.</span>
<span class="sd">                Default: (0, 1), this is the first two axis in spatial dimensions.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotator</span> <span class="o">=</span> <span class="n">Rotate90</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">spatial_axes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rotate90d.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate90d.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotator</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Rotate90d.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate90d.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Create inverse transform</span>
            <span class="n">spatial_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotator</span><span class="o">.</span><span class="n">spatial_axes</span>
            <span class="n">num_times_rotated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotator</span><span class="o">.</span><span class="n">k</span>
            <span class="n">num_times_to_rotate</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">num_times_rotated</span>
            <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">Rotate90</span><span class="p">(</span><span class="n">num_times_to_rotate</span><span class="p">,</span> <span class="n">spatial_axes</span><span class="p">)</span>
            <span class="c1"># Might need to convert to numpy</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="c1"># Apply inverse</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_transform</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="RandRotate90d"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90d">[docs]</a><span class="k">class</span> <span class="nc">RandRotate90d</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based version :py:class:`monai.transforms.RandRotate90`.</span>
<span class="sd">    With probability `prob`, input arrays are rotated by 90 degrees</span>
<span class="sd">    in the plane specified by `spatial_axes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandRotate90d.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90d.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">max_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">spatial_axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            keys: keys of the corresponding items to be transformed.</span>
<span class="sd">                See also: :py:class:`monai.transforms.compose.MapTransform`</span>
<span class="sd">            prob: probability of rotating.</span>
<span class="sd">                (Default 0.1, with 10% probability it returns a rotated array.)</span>
<span class="sd">            max_k: number of rotations will be sampled from `np.random.randint(max_k) + 1`.</span>
<span class="sd">                (Default 3)</span>
<span class="sd">            spatial_axes: 2 int numbers, defines the plane to rotate with 2 spatial axes.</span>
<span class="sd">                Default: (0, 1), this is the first two axis in spatial dimensions.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_k</span> <span class="o">=</span> <span class="n">max_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span> <span class="o">=</span> <span class="n">spatial_axes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rand_k</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="RandRotate90d.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90d.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rand_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandRotate90d.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90d.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">rotator</span> <span class="o">=</span> <span class="n">Rotate90</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rand_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotator</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;rand_k&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rand_k</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="RandRotate90d.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90d.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Check if random transform was actually performed (based on `prob`)</span>
            <span class="k">if</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">DO_TRANSFORM</span><span class="p">]:</span>
                <span class="c1"># Create inverse transform</span>
                <span class="n">num_times_rotated</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;rand_k&quot;</span><span class="p">]</span>
                <span class="n">num_times_to_rotate</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">num_times_rotated</span>
                <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">Rotate90</span><span class="p">(</span><span class="n">num_times_to_rotate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span><span class="p">)</span>
                <span class="c1"># Might need to convert to numpy</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="c1"># Apply inverse</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_transform</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Resized"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resized">[docs]</a><span class="k">class</span> <span class="nc">Resized</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Resize`.</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: keys of the corresponding items to be transformed.</span>
<span class="sd">            See also: :py:class:`monai.transforms.compose.MapTransform`</span>
<span class="sd">        spatial_size: expected shape of spatial dimensions after resize operation.</span>
<span class="sd">            if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">            corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">            to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">        mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">            The interpolation mode. Defaults to ``&quot;area&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">        align_corners: This only has an effect when mode is</span>
<span class="sd">            &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Default: None.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            It also can be a sequence of bool or None, each element corresponds to a key in ``keys``.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">InterpolateModeSequence</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resizer</span> <span class="o">=</span> <span class="n">Resize</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">spatial_size</span><span class="p">)</span>

<div class="viewcode-block" id="Resized.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resized.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">align_corners</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;align_corners&quot;</span><span class="p">:</span> <span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resizer</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Resized.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resized.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">orig_size</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">]</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
            <span class="n">align_corners</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span>
            <span class="c1"># Create inverse transform</span>
            <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">Resize</span><span class="p">(</span><span class="n">orig_size</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">)</span>
            <span class="c1"># Apply inverse transform</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_transform</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Affined"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Affined">[docs]</a><span class="k">class</span> <span class="nc">Affined</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Affine`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Affined.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Affined.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">rotate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            keys: keys of the corresponding items to be transformed.</span>
<span class="sd">            rotate_params: a rotation angle in radians, a scalar for 2D image, a tuple of 3 floats for 3D.</span>
<span class="sd">                Defaults to no rotation.</span>
<span class="sd">            shear_params: a tuple of 2 floats for 2D, a tuple of 6 floats for 3D. Defaults to no shearing.</span>
<span class="sd">            translate_params: a tuple of 2 floats for 2D, a tuple of 3 floats for 3D. Translation is in</span>
<span class="sd">                pixel/voxel relative to the center of the input image. Defaults to no translation.</span>
<span class="sd">            scale_params: a tuple of 2 floats for 2D, a tuple of 3 floats for 3D. Defaults to no scaling.</span>
<span class="sd">            spatial_size: output image spatial size.</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">                to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:class:`monai.transforms.compose.MapTransform`</span>
<span class="sd">            - :py:class:`RandAffineGrid` for the random affine parameters configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">affine</span> <span class="o">=</span> <span class="n">Affine</span><span class="p">(</span>
            <span class="n">rotate_params</span><span class="o">=</span><span class="n">rotate_params</span><span class="p">,</span>
            <span class="n">shear_params</span><span class="o">=</span><span class="n">shear_params</span><span class="p">,</span>
            <span class="n">translate_params</span><span class="o">=</span><span class="n">translate_params</span><span class="p">,</span>
            <span class="n">scale_params</span><span class="o">=</span><span class="n">scale_params</span><span class="p">,</span>
            <span class="n">spatial_size</span><span class="o">=</span><span class="n">spatial_size</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="Affined.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Affined.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">):</span>
            <span class="n">orig_size</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">orig_size</span><span class="o">=</span><span class="n">orig_size</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;affine&quot;</span><span class="p">:</span> <span class="n">affine</span><span class="p">,</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;padding_mode&quot;</span><span class="p">:</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">padding_mode</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Affined.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Affined.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">orig_size</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">]</span>
            <span class="c1"># Create inverse transform</span>
            <span class="n">fwd_affine</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
            <span class="n">padding_mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;padding_mode&quot;</span><span class="p">]</span>
            <span class="n">inv_affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">fwd_affine</span><span class="p">)</span>

            <span class="n">affine_grid</span> <span class="o">=</span> <span class="n">AffineGrid</span><span class="p">(</span><span class="n">affine</span><span class="o">=</span><span class="n">inv_affine</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">affine_grid</span><span class="p">(</span><span class="n">orig_size</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

            <span class="c1"># Apply inverse transform</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">)</span>

            <span class="c1"># Convert to numpy</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">out</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="RandAffined"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffined">[docs]</a><span class="k">class</span> <span class="nc">RandAffined</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.RandAffine`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandAffined.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffined.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rotate_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">cache_grid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            keys: keys of the corresponding items to be transformed.</span>
<span class="sd">            spatial_size: output image spatial size.</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">                to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">            prob: probability of returning a randomized affine grid.</span>
<span class="sd">                defaults to 0.1, with 10% chance returns a randomized grid.</span>
<span class="sd">            rotate_range: angle range in radians. If element `i` is iterable, then</span>
<span class="sd">                `uniform[-rotate_range[i][0], rotate_range[i][1])` will be used to generate the rotation parameter</span>
<span class="sd">                for the ith dimension. If not, `uniform[-rotate_range[i], rotate_range[i])` will be used. This can</span>
<span class="sd">                be altered on a per-dimension basis. E.g., `((0,3), 1, ...)`: for dim0, rotation will be in range</span>
<span class="sd">                `[0, 3]`, and for dim1 `[-1, 1]` will be used. Setting a single value will use `[-x, x]` for dim0</span>
<span class="sd">                and nothing for the remaining dimensions.</span>
<span class="sd">            shear_range: shear_range with format matching `rotate_range`.</span>
<span class="sd">            translate_range: translate_range with format matching `rotate_range`.</span>
<span class="sd">            scale_range: scaling_range with format matching `rotate_range`. A value of 1.0 is added to the result.</span>
<span class="sd">                This allows 0 to correspond to no change (i.e., a scaling of 1).</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            cache_grid: whether to cache the identity sampling grid.</span>
<span class="sd">                If the spatial size is not dynamically defined by input image, enabling this option could</span>
<span class="sd">                accelerate the transform.</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:class:`monai.transforms.compose.MapTransform`</span>
<span class="sd">            - :py:class:`RandAffineGrid` for the random affine parameters configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span> <span class="o">=</span> <span class="n">RandAffine</span><span class="p">(</span>
            <span class="n">prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># because probability handled in this class</span>
            <span class="n">rotate_range</span><span class="o">=</span><span class="n">rotate_range</span><span class="p">,</span>
            <span class="n">shear_range</span><span class="o">=</span><span class="n">shear_range</span><span class="p">,</span>
            <span class="n">translate_range</span><span class="o">=</span><span class="n">translate_range</span><span class="p">,</span>
            <span class="n">scale_range</span><span class="o">=</span><span class="n">scale_range</span><span class="p">,</span>
            <span class="n">spatial_size</span><span class="o">=</span><span class="n">spatial_size</span><span class="p">,</span>
            <span class="n">cache_grid</span><span class="o">=</span><span class="n">cache_grid</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="RandAffined.set_random_state"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffined.set_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_random_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;RandAffined&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="RandAffined.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffined.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span></div>

<div class="viewcode-block" id="RandAffined.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffined.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>

        <span class="n">sp_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1"># change image size or do random transform</span>
        <span class="n">do_resampling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sp_size</span> <span class="o">!=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># to be consistent with the self._do_transform case (dtype and device)</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">do_resampling</span><span class="p">:</span>  <span class="c1"># need to prepare grid</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">get_identity_grid</span><span class="p">(</span><span class="n">sp_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>  <span class="c1"># add some random factors</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">get_transformation_matrix</span><span class="p">()</span>  <span class="c1"># type: ignore[assignment]</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;affine&quot;</span><span class="p">:</span> <span class="n">affine</span><span class="p">,</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;padding_mode&quot;</span><span class="p">:</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">padding_mode</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="c1"># do the transform</span>
            <span class="k">if</span> <span class="n">do_resampling</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">)</span>
            <span class="c1"># if not doing transform and and spatial size is unchanged, only need to do numpy/torch conversion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">resampler</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">resampler</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>  <span class="c1"># type: ignore[union-attr]</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="RandAffined.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffined.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># if transform was not performed and spatial size is None, nothing to do.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">DO_TRANSFORM</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">spatial_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orig_size</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">]</span>
                <span class="c1"># Create inverse transform</span>
                <span class="n">fwd_affine</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
                <span class="n">padding_mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;padding_mode&quot;</span><span class="p">]</span>
                <span class="n">inv_affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">fwd_affine</span><span class="p">)</span>

                <span class="n">affine_grid</span> <span class="o">=</span> <span class="n">AffineGrid</span><span class="p">(</span><span class="n">affine</span><span class="o">=</span><span class="n">inv_affine</span><span class="p">)</span>
                <span class="n">grid</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">affine_grid</span><span class="p">(</span><span class="n">orig_size</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

                <span class="c1"># Apply inverse transform</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">)</span>

            <span class="c1"># Convert to numpy</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">out</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Rand2DElasticd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElasticd">[docs]</a><span class="k">class</span> <span class="nc">Rand2DElasticd</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Rand2DElastic`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Rand2DElasticd.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElasticd.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">spacing</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">magnitude_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rotate_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            keys: keys of the corresponding items to be transformed.</span>
<span class="sd">            spacing: distance in between the control points.</span>
<span class="sd">            magnitude_range: 2 int numbers, the random offsets will be generated from</span>
<span class="sd">                ``uniform[magnitude[0], magnitude[1])``.</span>
<span class="sd">            spatial_size: specifying output image spatial size [h, w].</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">                to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">            prob: probability of returning a randomized affine grid.</span>
<span class="sd">                defaults to 0.1, with 10% chance returns a randomized grid,</span>
<span class="sd">                otherwise returns a ``spatial_size`` centered area extracted from the input image.</span>
<span class="sd">            rotate_range: angle range in radians. If element `i` is iterable, then</span>
<span class="sd">                `uniform[-rotate_range[i][0], rotate_range[i][1])` will be used to generate the rotation parameter</span>
<span class="sd">                for the ith dimension. If not, `uniform[-rotate_range[i], rotate_range[i])` will be used. This can</span>
<span class="sd">                be altered on a per-dimension basis. E.g., `((0,3), 1, ...)`: for dim0, rotation will be in range</span>
<span class="sd">                `[0, 3]`, and for dim1 `[-1, 1]` will be used. Setting a single value will use `[-x, x]` for dim0</span>
<span class="sd">                and nothing for the remaining dimensions.</span>
<span class="sd">            shear_range: shear_range with format matching `rotate_range`.</span>
<span class="sd">            translate_range: translate_range with format matching `rotate_range`.</span>
<span class="sd">            scale_range: scaling_range with format matching `rotate_range`. A value of 1.0 is added to the result.</span>
<span class="sd">                This allows 0 to correspond to no change (i.e., a scaling of 1).</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:class:`RandAffineGrid` for the random affine parameters configurations.</span>
<span class="sd">            - :py:class:`Affine` for the affine transformation parameters configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span> <span class="o">=</span> <span class="n">Rand2DElastic</span><span class="p">(</span>
            <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span>
            <span class="n">magnitude_range</span><span class="o">=</span><span class="n">magnitude_range</span><span class="p">,</span>
            <span class="n">prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># because probability controlled by this class</span>
            <span class="n">rotate_range</span><span class="o">=</span><span class="n">rotate_range</span><span class="p">,</span>
            <span class="n">shear_range</span><span class="o">=</span><span class="n">shear_range</span><span class="p">,</span>
            <span class="n">translate_range</span><span class="o">=</span><span class="n">translate_range</span><span class="p">,</span>
            <span class="n">scale_range</span><span class="o">=</span><span class="n">scale_range</span><span class="p">,</span>
            <span class="n">spatial_size</span><span class="o">=</span><span class="n">spatial_size</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="Rand2DElasticd.set_random_state"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElasticd.set_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_random_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Rand2DElasticd&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Rand2DElasticd.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElasticd.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rand2DElasticd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElasticd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">sp_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span><span class="o">.</span><span class="n">deform_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="n">recompute_scale_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="nb">input</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">scale_factor</span><span class="o">=</span><span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span><span class="o">.</span><span class="n">deform_grid</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">InterpolateMode</span><span class="o">.</span><span class="n">BICUBIC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">CenterSpatialCrop</span><span class="p">(</span><span class="n">roi_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_2d_elastic</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Rand3DElasticd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElasticd">[docs]</a><span class="k">class</span> <span class="nc">Rand3DElasticd</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Rand3DElastic`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Rand3DElasticd.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElasticd.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">sigma_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">magnitude_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rotate_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            keys: keys of the corresponding items to be transformed.</span>
<span class="sd">            sigma_range: a Gaussian kernel with standard deviation sampled from</span>
<span class="sd">                ``uniform[sigma_range[0], sigma_range[1])`` will be used to smooth the random offset grid.</span>
<span class="sd">            magnitude_range: the random offsets on the grid will be generated from</span>
<span class="sd">                ``uniform[magnitude[0], magnitude[1])``.</span>
<span class="sd">            spatial_size: specifying output image spatial size [h, w, d].</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, 32, -1)` will be adapted</span>
<span class="sd">                to `(32, 32, 64)` if the third spatial dimension size of img is `64`.</span>
<span class="sd">            prob: probability of returning a randomized affine grid.</span>
<span class="sd">                defaults to 0.1, with 10% chance returns a randomized grid,</span>
<span class="sd">                otherwise returns a ``spatial_size`` centered area extracted from the input image.</span>
<span class="sd">            rotate_range: angle range in radians. If element `i` is iterable, then</span>
<span class="sd">                `uniform[-rotate_range[i][0], rotate_range[i][1])` will be used to generate the rotation parameter</span>
<span class="sd">                for the ith dimension. If not, `uniform[-rotate_range[i], rotate_range[i])` will be used. This can</span>
<span class="sd">                be altered on a per-dimension basis. E.g., `((0,3), 1, ...)`: for dim0, rotation will be in range</span>
<span class="sd">                `[0, 3]`, and for dim1 `[-1, 1]` will be used. Setting a single value will use `[-x, x]` for dim0</span>
<span class="sd">                and nothing for the remaining dimensions.</span>
<span class="sd">            shear_range: shear_range with format matching `rotate_range`.</span>
<span class="sd">            translate_range: translate_range with format matching `rotate_range`.</span>
<span class="sd">            scale_range: scaling_range with format matching `rotate_range`. A value of 1.0 is added to the result.</span>
<span class="sd">                This allows 0 to correspond to no change (i.e., a scaling of 1).</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:class:`RandAffineGrid` for the random affine parameters configurations.</span>
<span class="sd">            - :py:class:`Affine` for the affine transformation parameters configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span> <span class="o">=</span> <span class="n">Rand3DElastic</span><span class="p">(</span>
            <span class="n">sigma_range</span><span class="o">=</span><span class="n">sigma_range</span><span class="p">,</span>
            <span class="n">magnitude_range</span><span class="o">=</span><span class="n">magnitude_range</span><span class="p">,</span>
            <span class="n">prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># because probability controlled by this class</span>
            <span class="n">rotate_range</span><span class="o">=</span><span class="n">rotate_range</span><span class="p">,</span>
            <span class="n">shear_range</span><span class="o">=</span><span class="n">shear_range</span><span class="p">,</span>
            <span class="n">translate_range</span><span class="o">=</span><span class="n">translate_range</span><span class="p">,</span>
            <span class="n">scale_range</span><span class="o">=</span><span class="n">scale_range</span><span class="p">,</span>
            <span class="n">spatial_size</span><span class="o">=</span><span class="n">spatial_size</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="Rand3DElasticd.set_random_state"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElasticd.set_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_random_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Rand3DElasticd&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Rand3DElasticd.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElasticd.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rand3DElasticd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElasticd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">sp_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">grid_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">device</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">GaussianFilter</span><span class="p">(</span><span class="n">spatial_dims</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">truncated</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">rand_offset</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">offset</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">magnitude</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_3d_elastic</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Flipd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Flipd">[docs]</a><span class="k">class</span> <span class="nc">Flipd</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Flip`.</span>

<span class="sd">    See `numpy.flip` for additional details.</span>
<span class="sd">    https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: Keys to pick data for transformation.</span>
<span class="sd">        spatial_axis: Spatial axes along which to flip over. Default is None.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span> <span class="o">=</span> <span class="n">Flip</span><span class="p">(</span><span class="n">spatial_axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">)</span>

<div class="viewcode-block" id="Flipd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Flipd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Flipd.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Flipd.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Might need to convert to numpy</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="c1"># Inverse is same as forward</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="RandFlipd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandFlipd">[docs]</a><span class="k">class</span> <span class="nc">RandFlipd</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based version :py:class:`monai.transforms.RandFlip`.</span>

<span class="sd">    See `numpy.flip` for additional details.</span>
<span class="sd">    https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: Keys to pick data for transformation.</span>
<span class="sd">        prob: Probability of flipping.</span>
<span class="sd">        spatial_axis: Spatial axes along which to flip over. Default is None.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axis</span> <span class="o">=</span> <span class="n">spatial_axis</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span> <span class="o">=</span> <span class="n">Flip</span><span class="p">(</span><span class="n">spatial_axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">)</span>

<div class="viewcode-block" id="RandFlipd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandFlipd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="RandFlipd.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandFlipd.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Check if random transform was actually performed (based on `prob`)</span>
            <span class="k">if</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">DO_TRANSFORM</span><span class="p">]:</span>
                <span class="c1"># Might need to convert to numpy</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="c1"># Inverse is same as forward</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="RandAxisFlipd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAxisFlipd">[docs]</a><span class="k">class</span> <span class="nc">RandAxisFlipd</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based version :py:class:`monai.transforms.RandAxisFlip`.</span>

<span class="sd">    See `numpy.flip` for additional details.</span>
<span class="sd">    https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: Keys to pick data for transformation.</span>
<span class="sd">        prob: Probability of flipping.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="RandAxisFlipd.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAxisFlipd.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandAxisFlipd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAxisFlipd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">flipper</span> <span class="o">=</span> <span class="n">Flip</span><span class="p">(</span><span class="n">spatial_axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">flipper</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="RandAxisFlipd.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAxisFlipd.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Check if random transform was actually performed (based on `prob`)</span>
            <span class="k">if</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">DO_TRANSFORM</span><span class="p">]:</span>
                <span class="n">flipper</span> <span class="o">=</span> <span class="n">Flip</span><span class="p">(</span><span class="n">spatial_axis</span><span class="o">=</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
                <span class="c1"># Might need to convert to numpy</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="c1"># Inverse is same as forward</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">flipper</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Rotated"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotated">[docs]</a><span class="k">class</span> <span class="nc">Rotated</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Rotate`.</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: Keys to pick data for transformation.</span>
<span class="sd">        angle: Rotation angle(s) in radians.</span>
<span class="sd">        keep_size: If it is False, the output shape is adapted so that the</span>
<span class="sd">            input array is contained completely in the output.</span>
<span class="sd">            If it is True, the output shape is the same as the input. Default is True.</span>
<span class="sd">        mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">            Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">        padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">            Padding mode for outside grid values. Defaults to ``&quot;border&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">        align_corners: Defaults to False.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            It also can be a sequence of bool, each element corresponds to a key in ``keys``.</span>
<span class="sd">        dtype: data type for resampling computation. Defaults to ``np.float64`` for best precision.</span>
<span class="sd">            If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">            the output data type is always ``np.float32``.</span>
<span class="sd">            It also can be a sequence of dtype or None, each element corresponds to a key in ``keys``.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">angle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">BORDER</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">DtypeLike</span><span class="p">],</span> <span class="n">DtypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotator</span> <span class="o">=</span> <span class="n">Rotate</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="n">keep_size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>

<div class="viewcode-block" id="Rotated.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotated.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">):</span>
            <span class="n">orig_size</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotator</span><span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotator</span><span class="o">.</span><span class="n">get_rotation_matrix</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">orig_size</span><span class="o">=</span><span class="n">orig_size</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;rot_mat&quot;</span><span class="p">:</span> <span class="n">rot_mat</span><span class="p">,</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;padding_mode&quot;</span><span class="p">:</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">padding_mode</span><span class="p">,</span>
                    <span class="s2">&quot;align_corners&quot;</span><span class="p">:</span> <span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Rotated.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotated.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Create inverse transform</span>
            <span class="n">fwd_rot_mat</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;rot_mat&quot;</span><span class="p">]</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
            <span class="n">padding_mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;padding_mode&quot;</span><span class="p">]</span>
            <span class="n">align_corners</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span>
            <span class="n">inv_rot_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">fwd_rot_mat</span><span class="p">)</span>

            <span class="n">xform</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span>
                <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
                <span class="n">reverse_indexing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">xform</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">inv_rot_mat</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)),</span>
                <span class="n">spatial_size</span><span class="o">=</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="RandRotated"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotated">[docs]</a><span class="k">class</span> <span class="nc">RandRotated</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based version :py:class:`monai.transforms.RandRotate`</span>
<span class="sd">    Randomly rotates the input arrays.</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: Keys to pick data for transformation.</span>
<span class="sd">        range_x: Range of rotation angle in radians in the plane defined by the first and second axes.</span>
<span class="sd">            If single number, angle is uniformly sampled from (-range_x, range_x).</span>
<span class="sd">        range_y: Range of rotation angle in radians in the plane defined by the first and third axes.</span>
<span class="sd">            If single number, angle is uniformly sampled from (-range_y, range_y).</span>
<span class="sd">        range_z: Range of rotation angle in radians in the plane defined by the second and third axes.</span>
<span class="sd">            If single number, angle is uniformly sampled from (-range_z, range_z).</span>
<span class="sd">        prob: Probability of rotation.</span>
<span class="sd">        keep_size: If it is False, the output shape is adapted so that the</span>
<span class="sd">            input array is contained completely in the output.</span>
<span class="sd">            If it is True, the output shape is the same as the input. Default is True.</span>
<span class="sd">        mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">            Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">        padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">            Padding mode for outside grid values. Defaults to ``&quot;border&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">        align_corners: Defaults to False.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            It also can be a sequence of bool, each element corresponds to a key in ``keys``.</span>
<span class="sd">        dtype: data type for resampling computation. Defaults to ``np.float64`` for best precision.</span>
<span class="sd">            If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">            the output data type is always ``np.float32``.</span>
<span class="sd">            It also can be a sequence of dtype or None, each element corresponds to a key in ``keys``.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">range_x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">range_y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">range_z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleModeSequence</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadModeSequence</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">BORDER</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">DtypeLike</span><span class="p">],</span> <span class="n">DtypeLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_x</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">range_x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_y</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">range_y</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_y</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_z</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">range_z</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_z</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="o">=</span> <span class="n">keep_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span>

<div class="viewcode-block" id="RandRotated.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotated.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="RandRotated.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotated.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">angle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">rotator</span> <span class="o">=</span> <span class="n">Rotate</span><span class="p">(</span>
            <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span>
            <span class="n">keep_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">):</span>
            <span class="n">orig_size</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotator</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                    <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotator</span><span class="o">.</span><span class="n">get_rotation_matrix</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">orig_size</span><span class="o">=</span><span class="n">orig_size</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;rot_mat&quot;</span><span class="p">:</span> <span class="n">rot_mat</span><span class="p">,</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;padding_mode&quot;</span><span class="p">:</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">padding_mode</span><span class="p">,</span>
                    <span class="s2">&quot;align_corners&quot;</span><span class="p">:</span> <span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="RandRotated.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotated.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Check if random transform was actually performed (based on `prob`)</span>
            <span class="k">if</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">DO_TRANSFORM</span><span class="p">]:</span>
                <span class="c1"># Create inverse transform</span>
                <span class="n">fwd_rot_mat</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;rot_mat&quot;</span><span class="p">]</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
                <span class="n">padding_mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;padding_mode&quot;</span><span class="p">]</span>
                <span class="n">align_corners</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span>
                <span class="n">inv_rot_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">fwd_rot_mat</span><span class="p">)</span>

                <span class="n">xform</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span>
                    <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                    <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
                    <span class="n">reverse_indexing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">xform</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">inv_rot_mat</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)),</span>
                    <span class="n">spatial_size</span><span class="o">=</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="Zoomd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Zoomd">[docs]</a><span class="k">class</span> <span class="nc">Zoomd</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.Zoom`.</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: Keys to pick data for transformation.</span>
<span class="sd">        zoom: The zoom factor along the spatial axes.</span>
<span class="sd">            If a float, zoom is the same for each spatial axis.</span>
<span class="sd">            If a sequence, zoom should contain one value for each spatial axis.</span>
<span class="sd">        mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">            The interpolation mode. Defaults to ``&quot;area&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">        padding_mode: {``&quot;constant&quot;``, ``&quot;edge``&quot;, ``&quot;linear_ramp``&quot;, ``&quot;maximum``&quot;, ``&quot;mean``&quot;, `&quot;median``&quot;,</span>
<span class="sd">            ``&quot;minimum``&quot;, `&quot;reflect``&quot;, ``&quot;symmetric``&quot;, ``&quot;wrap``&quot;, ``&quot;empty``&quot;, ``&quot;&lt;function&gt;``&quot;}</span>
<span class="sd">            The mode to pad data after zooming.</span>
<span class="sd">            See also: https://numpy.org/doc/stable/reference/generated/numpy.pad.html</span>
<span class="sd">        align_corners: This only has an effect when mode is</span>
<span class="sd">            &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Default: None.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            It also can be a sequence of bool or None, each element corresponds to a key in ``keys``.</span>
<span class="sd">        keep_size: Should keep original size (pad if needed), default is True.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">zoom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">InterpolateModeSequence</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">NumpyPadModeSequence</span> <span class="o">=</span> <span class="n">NumpyPadMode</span><span class="o">.</span><span class="n">EDGE</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zoomer</span> <span class="o">=</span> <span class="n">Zoom</span><span class="p">(</span><span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="n">keep_size</span><span class="p">)</span>

<div class="viewcode-block" id="Zoomd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Zoomd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">,</span> <span class="n">align_corners</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;padding_mode&quot;</span><span class="p">:</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">padding_mode</span><span class="p">,</span>
                    <span class="s2">&quot;align_corners&quot;</span><span class="p">:</span> <span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zoomer</span><span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Zoomd.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Zoomd.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Create inverse transform</span>
            <span class="n">zoom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoomer</span><span class="o">.</span><span class="n">zoom</span><span class="p">)</span>
            <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">Zoom</span><span class="p">(</span><span class="n">zoom</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoom</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">keep_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zoomer</span><span class="o">.</span><span class="n">keep_size</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
            <span class="n">padding_mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;padding_mode&quot;</span><span class="p">]</span>
            <span class="n">align_corners</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span>
            <span class="c1"># Apply inverse</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Size might be out by 1 voxel so pad</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialPad</span><span class="p">(</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="RandZoomd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandZoomd">[docs]</a><span class="k">class</span> <span class="nc">RandZoomd</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">,</span> <span class="n">InvertibleTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dict-based version :py:class:`monai.transforms.RandZoom`.</span>

<span class="sd">    Args:</span>
<span class="sd">        keys: Keys to pick data for transformation.</span>
<span class="sd">        prob: Probability of zooming.</span>
<span class="sd">        min_zoom: Min zoom factor. Can be float or sequence same size as image.</span>
<span class="sd">            If a float, select a random factor from `[min_zoom, max_zoom]` then apply to all spatial dims</span>
<span class="sd">            to keep the original spatial shape ratio.</span>
<span class="sd">            If a sequence, min_zoom should contain one value for each spatial axis.</span>
<span class="sd">            If 2 values provided for 3D data, use the first value for both H &amp; W dims to keep the same zoom ratio.</span>
<span class="sd">        max_zoom: Max zoom factor. Can be float or sequence same size as image.</span>
<span class="sd">            If a float, select a random factor from `[min_zoom, max_zoom]` then apply to all spatial dims</span>
<span class="sd">            to keep the original spatial shape ratio.</span>
<span class="sd">            If a sequence, max_zoom should contain one value for each spatial axis.</span>
<span class="sd">            If 2 values provided for 3D data, use the first value for both H &amp; W dims to keep the same zoom ratio.</span>
<span class="sd">        mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">            The interpolation mode. Defaults to ``&quot;area&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            It also can be a sequence of string, each element corresponds to a key in ``keys``.</span>
<span class="sd">        padding_mode: {``&quot;constant&quot;``, ``&quot;edge``&quot;, ``&quot;linear_ramp``&quot;, ``&quot;maximum``&quot;, ``&quot;mean``&quot;, `&quot;median``&quot;,</span>
<span class="sd">            ``&quot;minimum``&quot;, `&quot;reflect``&quot;, ``&quot;symmetric``&quot;, ``&quot;wrap``&quot;, ``&quot;empty``&quot;, ``&quot;&lt;function&gt;``&quot;}</span>
<span class="sd">            The mode to pad data after zooming.</span>
<span class="sd">            See also: https://numpy.org/doc/stable/reference/generated/numpy.pad.html</span>
<span class="sd">        align_corners: This only has an effect when mode is</span>
<span class="sd">            &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Default: None.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            It also can be a sequence of bool or None, each element corresponds to a key in ``keys``.</span>
<span class="sd">        keep_size: Should keep original size (pad if needed), default is True.</span>
<span class="sd">        allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">min_zoom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">max_zoom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">InterpolateModeSequence</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">NumpyPadModeSequence</span> <span class="o">=</span> <span class="n">NumpyPadMode</span><span class="o">.</span><span class="n">EDGE</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MapTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">min_zoom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">max_zoom</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_zoom</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_zoom</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;min_zoom and max_zoom must have same length.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">align_corners</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="o">=</span> <span class="n">keep_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>

<div class="viewcode-block" id="RandZoomd.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandZoomd.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_zoom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_zoom</span><span class="p">)]</span></div>

<div class="viewcode-block" id="RandZoomd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandZoomd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># match the spatial dim of first item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">img_dims</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># to keep the spatial shape ratio, use same random zoom factor for all dims</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">img_dims</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># if 2 zoom factors provided for 3D data, use the first factor for H and W dims, second factor for D dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_dims</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">zoomer</span> <span class="o">=</span> <span class="n">Zoom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">,</span> <span class="n">align_corners</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_transform</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">extra_info</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;zoom&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">,</span>
                    <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode</span><span class="p">,</span>
                    <span class="s2">&quot;padding_mode&quot;</span><span class="p">:</span> <span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">Enum</span><span class="p">)</span> <span class="k">else</span> <span class="n">padding_mode</span><span class="p">,</span>
                    <span class="s2">&quot;align_corners&quot;</span><span class="p">:</span> <span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">zoomer</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                    <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="RandZoomd.inverse"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandZoomd.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_most_recent_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># Check if random transform was actually performed (based on `prob`)</span>
            <span class="k">if</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">DO_TRANSFORM</span><span class="p">]:</span>
                <span class="c1"># Create inverse transform</span>
                <span class="n">zoom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;zoom&quot;</span><span class="p">])</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
                <span class="n">padding_mode</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;padding_mode&quot;</span><span class="p">]</span>
                <span class="n">align_corners</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span>
                <span class="n">inverse_transform</span> <span class="o">=</span> <span class="n">Zoom</span><span class="p">(</span><span class="n">zoom</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoom</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">keep_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">)</span>
                <span class="c1"># Apply inverse</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_transform</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span>
                    <span class="n">align_corners</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Size might be out by 1 voxel so pad</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialPad</span><span class="p">(</span><span class="n">transform</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">ORIG_SIZE</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># Remove the applied transform</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="AddCoordinateChannelsd"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AddCoordinateChannelsd">[docs]</a><span class="k">class</span> <span class="nc">AddCoordinateChannelsd</span><span class="p">(</span><span class="n">MapTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary-based wrapper of :py:class:`monai.transforms.AddCoordinateChannels`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AddCoordinateChannelsd.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AddCoordinateChannelsd.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">KeysCollection</span><span class="p">,</span> <span class="n">spatial_channels</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">allow_missing_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            keys: keys of the corresponding items to be transformed.</span>
<span class="sd">                See also: :py:class:`monai.transforms.compose.MapTransform`</span>
<span class="sd">            allow_missing_keys: don&#39;t raise exception if key is missing.</span>
<span class="sd">            spatial_channels: the spatial dimensions that are to have their coordinates encoded in a channel and</span>
<span class="sd">                appended to the input. E.g., `(1,2,3)` will append three channels to the input, encoding the</span>
<span class="sd">                coordinates of the input&#39;s three spatial dimensions. It is assumed dimension 0 is the channel.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">allow_missing_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coordinate_channels</span> <span class="o">=</span> <span class="n">AddCoordinateChannels</span><span class="p">(</span><span class="n">spatial_channels</span><span class="p">)</span></div>

<div class="viewcode-block" id="AddCoordinateChannelsd.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AddCoordinateChannelsd.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_coordinate_channels</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">d</span></div></div>


<span class="n">SpacingD</span> <span class="o">=</span> <span class="n">SpacingDict</span> <span class="o">=</span> <span class="n">Spacingd</span>
<span class="n">OrientationD</span> <span class="o">=</span> <span class="n">OrientationDict</span> <span class="o">=</span> <span class="n">Orientationd</span>
<span class="n">Rotate90D</span> <span class="o">=</span> <span class="n">Rotate90Dict</span> <span class="o">=</span> <span class="n">Rotate90d</span>
<span class="n">RandRotate90D</span> <span class="o">=</span> <span class="n">RandRotate90Dict</span> <span class="o">=</span> <span class="n">RandRotate90d</span>
<span class="n">ResizeD</span> <span class="o">=</span> <span class="n">ResizeDict</span> <span class="o">=</span> <span class="n">Resized</span>
<span class="n">AffineD</span> <span class="o">=</span> <span class="n">AffineDict</span> <span class="o">=</span> <span class="n">Affined</span>
<span class="n">RandAffineD</span> <span class="o">=</span> <span class="n">RandAffineDict</span> <span class="o">=</span> <span class="n">RandAffined</span>
<span class="n">Rand2DElasticD</span> <span class="o">=</span> <span class="n">Rand2DElasticDict</span> <span class="o">=</span> <span class="n">Rand2DElasticd</span>
<span class="n">Rand3DElasticD</span> <span class="o">=</span> <span class="n">Rand3DElasticDict</span> <span class="o">=</span> <span class="n">Rand3DElasticd</span>
<span class="n">FlipD</span> <span class="o">=</span> <span class="n">FlipDict</span> <span class="o">=</span> <span class="n">Flipd</span>
<span class="n">RandFlipD</span> <span class="o">=</span> <span class="n">RandFlipDict</span> <span class="o">=</span> <span class="n">RandFlipd</span>
<span class="n">RandAxisFlipD</span> <span class="o">=</span> <span class="n">RandAxisFlipDict</span> <span class="o">=</span> <span class="n">RandAxisFlipd</span>
<span class="n">RotateD</span> <span class="o">=</span> <span class="n">RotateDict</span> <span class="o">=</span> <span class="n">Rotated</span>
<span class="n">RandRotateD</span> <span class="o">=</span> <span class="n">RandRotateDict</span> <span class="o">=</span> <span class="n">RandRotated</span>
<span class="n">ZoomD</span> <span class="o">=</span> <span class="n">ZoomDict</span> <span class="o">=</span> <span class="n">Zoomd</span>
<span class="n">RandZoomD</span> <span class="o">=</span> <span class="n">RandZoomDict</span> <span class="o">=</span> <span class="n">RandZoomd</span>
<span class="n">AddCoordinateChannelsD</span> <span class="o">=</span> <span class="n">AddCoordinateChannelsDict</span> <span class="o">=</span> <span class="n">AddCoordinateChannelsd</span>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2021 MONAI Consortium.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>