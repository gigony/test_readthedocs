
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>monai.transforms.spatial.array &#8212; MONAI 0.6.0 Documentation</title>
    
  <link href="../../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/MONAI-logo-color.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../whatsnew.html">
  Whatâ€™s New
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../highlights.html">
  Modules Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../installation.html">
  Installation Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../contrib.html">
  Development
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/Project-MONAI/tutorials">Tutorials<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/project-monai/monai" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/projectmonai" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for monai.transforms.spatial.array</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020 - 2021 MONAI Consortium</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A collection of &quot;vanilla&quot; transforms for spatial operations</span>
<span class="sd">https://github.com/Project-MONAI/MONAI/wiki/MONAI_Design</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">monai.config</span> <span class="kn">import</span> <span class="n">USE_COMPILED</span><span class="p">,</span> <span class="n">DtypeLike</span>
<span class="kn">from</span> <span class="nn">monai.data.utils</span> <span class="kn">import</span> <span class="n">compute_shape_offset</span><span class="p">,</span> <span class="n">to_affine_nd</span><span class="p">,</span> <span class="n">zoom_affine</span>
<span class="kn">from</span> <span class="nn">monai.networks.layers</span> <span class="kn">import</span> <span class="n">AffineTransform</span><span class="p">,</span> <span class="n">GaussianFilter</span><span class="p">,</span> <span class="n">grid_pull</span>
<span class="kn">from</span> <span class="nn">monai.transforms.croppad.array</span> <span class="kn">import</span> <span class="n">CenterSpatialCrop</span>
<span class="kn">from</span> <span class="nn">monai.transforms.transform</span> <span class="kn">import</span> <span class="n">Randomizable</span><span class="p">,</span> <span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">ThreadUnsafe</span><span class="p">,</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">monai.transforms.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">create_control_grid</span><span class="p">,</span>
    <span class="n">create_grid</span><span class="p">,</span>
    <span class="n">create_rotate</span><span class="p">,</span>
    <span class="n">create_scale</span><span class="p">,</span>
    <span class="n">create_shear</span><span class="p">,</span>
    <span class="n">create_translate</span><span class="p">,</span>
    <span class="n">map_spatial_axes</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">monai.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GridSampleMode</span><span class="p">,</span>
    <span class="n">GridSamplePadMode</span><span class="p">,</span>
    <span class="n">InterpolateMode</span><span class="p">,</span>
    <span class="n">NumpyPadMode</span><span class="p">,</span>
    <span class="n">ensure_tuple</span><span class="p">,</span>
    <span class="n">ensure_tuple_rep</span><span class="p">,</span>
    <span class="n">ensure_tuple_size</span><span class="p">,</span>
    <span class="n">fall_back_tuple</span><span class="p">,</span>
    <span class="n">issequenceiterable</span><span class="p">,</span>
    <span class="n">optional_import</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">nib</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;nibabel&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Spacing&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Orientation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Flip&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Resize&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rotate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Zoom&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rotate90&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotate90&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRotate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandFlip&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAxisFlip&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandZoom&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AffineGrid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAffineGrid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandDeformGrid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Resample&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Affine&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAffine&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand2DElastic&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Rand3DElastic&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AddCoordinateChannels&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">RandRange</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">]]</span>


<div class="viewcode-block" id="Spacing"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Spacing">[docs]</a><span class="k">class</span> <span class="nc">Spacing</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample input image into the specified `pixdim`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spacing.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Spacing.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pixdim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">diagonal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">BORDER</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            pixdim: output voxel spacing. if providing a single number, will use it for the first dimension.</span>
<span class="sd">                items of the pixdim sequence map to the spatial dimensions of input image, if length</span>
<span class="sd">                of pixdim sequence is longer than image spatial dimensions, will ignore the longer part,</span>
<span class="sd">                if shorter, will pad with `1.0`.</span>
<span class="sd">                if the components of the `pixdim` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of the origial pixdim, which is computed from the `affine`</span>
<span class="sd">                matrix of input image.</span>
<span class="sd">            diagonal: whether to resample the input to have a diagonal affine matrix.</span>
<span class="sd">                If True, the input data is resampled to the following affine::</span>

<span class="sd">                    np.diag((pixdim_0, pixdim_1, ..., pixdim_n, 1))</span>

<span class="sd">                This effectively resets the volume to the world coordinate system (RAS+ in nibabel).</span>
<span class="sd">                The original orientation, rotation, shearing are not preserved.</span>

<span class="sd">                If False, this transform preserves the axes orientation, orthogonal rotation and</span>
<span class="sd">                translation components from the original affine. This option will not flip/swap axes</span>
<span class="sd">                of the original data.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;border&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            align_corners: Geometrically, we consider the pixels of the input as squares rather than points.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            dtype: data type for resampling computation. Defaults to ``np.float64`` for best precision.</span>
<span class="sd">                If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">                the output data type is always ``np.float32``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixdim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ensure_tuple</span><span class="p">(</span><span class="n">pixdim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span> <span class="o">=</span> <span class="n">diagonal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">align_corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span></div>

<div class="viewcode-block" id="Spacing.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Spacing.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">affine</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_spatial_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            data_array: in shape (num_channels, H[, W, ...]).</span>
<span class="sd">            affine (matrix): (N+1)x(N+1) original affine matrix for spatially ND `data_array`. Defaults to identity.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            align_corners: Geometrically, we consider the pixels of the input as squares rather than points.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            dtype: data type for resampling computation. Defaults to ``self.dtype``.</span>
<span class="sd">                If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">                the output data type is always ``np.float32``.</span>
<span class="sd">            output_spatial_shape: specify the shape of the output data_array. This is typically useful for</span>
<span class="sd">                the inverse of `Spacingd` where sometimes we could not compute the exact shape due to the quantization</span>
<span class="sd">                error with the affines.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When ``data_array`` has no spatial dimensions.</span>
<span class="sd">            ValueError: When ``pixdim`` is nonpositive.</span>

<span class="sd">        Returns:</span>
<span class="sd">            data_array (resampled into `self.pixdim`), original affine, current affine.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">data_array</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">sr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data_array must have at least one spatial dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default to identity</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">affine_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">affine_</span> <span class="o">=</span> <span class="n">to_affine_nd</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>

        <span class="n">out_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixdim</span><span class="p">[:</span><span class="n">sr</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">out_d</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">sr</span><span class="p">:</span>
            <span class="n">out_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_d</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">sr</span> <span class="o">-</span> <span class="n">out_d</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

        <span class="c1"># compute output affine, shape and offset</span>
        <span class="n">new_affine</span> <span class="o">=</span> <span class="n">zoom_affine</span><span class="p">(</span><span class="n">affine_</span><span class="p">,</span> <span class="n">out_d</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">)</span>
        <span class="n">output_shape</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">compute_shape_offset</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">affine_</span><span class="p">,</span> <span class="n">new_affine</span><span class="p">)</span>
        <span class="n">new_affine</span><span class="p">[:</span><span class="n">sr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">[:</span><span class="n">sr</span><span class="p">]</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">affine_</span><span class="p">)</span> <span class="o">@</span> <span class="n">new_affine</span>
        <span class="c1"># adapt to the actual rank</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">to_affine_nd</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>

        <span class="c1"># no resampling if it&#39;s identity transform</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transform</span><span class="p">))),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
            <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">new_affine</span> <span class="o">=</span> <span class="n">to_affine_nd</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">new_affine</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">output_data</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">new_affine</span>

        <span class="c1"># resample</span>
        <span class="n">affine_xform</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span>
            <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span>
            <span class="n">align_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
            <span class="n">reverse_indexing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output_data</span> <span class="o">=</span> <span class="n">affine_xform</span><span class="p">(</span>
            <span class="c1"># AffineTransform requires a batch dim</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">)),</span>
            <span class="n">spatial_size</span><span class="o">=</span><span class="n">output_shape</span> <span class="k">if</span> <span class="n">output_spatial_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output_spatial_shape</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">output_data</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">new_affine</span> <span class="o">=</span> <span class="n">to_affine_nd</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">new_affine</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output_data</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">new_affine</span></div></div>


<div class="viewcode-block" id="Orientation"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Orientation">[docs]</a><span class="k">class</span> <span class="nc">Orientation</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the input image&#39;s orientation into the specified based on `axcodes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Orientation.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Orientation.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axcodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_closest_canonical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="s2">&quot;LPI&quot;</span><span class="p">,</span> <span class="s2">&quot;RAS&quot;</span><span class="p">)),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            axcodes: N elements sequence for spatial ND input&#39;s orientation.</span>
<span class="sd">                e.g. axcodes=&#39;RAS&#39; represents 3D orientation:</span>
<span class="sd">                (Left, Right), (Posterior, Anterior), (Inferior, Superior).</span>
<span class="sd">                default orientation labels options are: &#39;L&#39; and &#39;R&#39; for the first dimension,</span>
<span class="sd">                &#39;P&#39; and &#39;A&#39; for the second, &#39;I&#39; and &#39;S&#39; for the third.</span>
<span class="sd">            as_closest_canonical: if True, load the image as closest to canonical axis format.</span>
<span class="sd">            labels: optional, None or sequence of (2,) sequences</span>
<span class="sd">                (2,) sequences are labels for (beginning, end) of output axis.</span>
<span class="sd">                Defaults to ``((&#39;L&#39;, &#39;R&#39;), (&#39;P&#39;, &#39;A&#39;), (&#39;I&#39;, &#39;S&#39;))``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When ``axcodes=None`` and ``as_closest_canonical=True``. Incompatible values.</span>

<span class="sd">        See Also: `nibabel.orientations.ornt2axcodes`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axcodes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">as_closest_canonical</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible values: axcodes=None and as_closest_canonical=True.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axcodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">as_closest_canonical</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;using as_closest_canonical=True, axcodes ignored.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axcodes</span> <span class="o">=</span> <span class="n">axcodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_closest_canonical</span> <span class="o">=</span> <span class="n">as_closest_canonical</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="Orientation.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Orientation.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">affine</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        original orientation of `data_array` is defined by `affine`.</span>

<span class="sd">        Args:</span>
<span class="sd">            data_array: in shape (num_channels, H[, W, ...]).</span>
<span class="sd">            affine (matrix): (N+1)x(N+1) original affine matrix for spatially ND `data_array`. Defaults to identity.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When ``data_array`` has no spatial dimensions.</span>
<span class="sd">            ValueError: When ``axcodes`` spatiality differs from ``data_array``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            data_array (reoriented in `self.axcodes`), original axcodes, current axcodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">sr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data_array must have at least one spatial dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">affine_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">affine_</span> <span class="o">=</span> <span class="n">to_affine_nd</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">io_orientation</span><span class="p">(</span><span class="n">affine_</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_closest_canonical</span><span class="p">:</span>
            <span class="n">spatial_ornt</span> <span class="o">=</span> <span class="n">src</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axcodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">axcodes2ornt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axcodes</span><span class="p">[:</span><span class="n">sr</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;axcodes must match data_array spatially, got axcodes=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axcodes</span><span class="p">)</span><span class="si">}</span><span class="s2">D data_array=</span><span class="si">{</span><span class="n">sr</span><span class="si">}</span><span class="s2">D&quot;</span>
                <span class="p">)</span>
            <span class="n">spatial_ornt</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">ornt_transform</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
        <span class="n">ornt</span> <span class="o">=</span> <span class="n">spatial_ornt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ornt</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># skip channel dim</span>
        <span class="n">ornt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="n">ornt</span><span class="p">])</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">nib</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">apply_orientation</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span> <span class="n">ornt</span><span class="p">))</span>
        <span class="n">new_affine</span> <span class="o">=</span> <span class="n">affine_</span> <span class="o">@</span> <span class="n">nib</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">inv_ornt_aff</span><span class="p">(</span><span class="n">spatial_ornt</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="n">new_affine</span> <span class="o">=</span> <span class="n">to_affine_nd</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">new_affine</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_array</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">new_affine</span></div></div>


<div class="viewcode-block" id="Flip"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Flip">[docs]</a><span class="k">class</span> <span class="nc">Flip</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverses the order of elements along the given spatial axis. Preserves shape.</span>
<span class="sd">    Uses ``np.flip`` in practice. See numpy.flip for additional details:</span>
<span class="sd">    https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html.</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_axis: spatial axes along which to flip over. Default is None.</span>
<span class="sd">            The default `axis=None` will flip over all of the axes of the input array.</span>
<span class="sd">            If axis is negative it counts from the last to the first axis.</span>
<span class="sd">            If axis is a tuple of ints, flipping is performed on all of the axes</span>
<span class="sd">            specified in the tuple.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axis</span> <span class="o">=</span> <span class="n">spatial_axis</span>

<div class="viewcode-block" id="Flip.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Flip.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: (num_channels, H[, W, ..., ]),</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">map_spatial_axes</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Resize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resize">[docs]</a><span class="k">class</span> <span class="nc">Resize</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize the input image to given spatial size (with scaling, not cropping/padding).</span>
<span class="sd">    Implemented using :py:class:`torch.nn.functional.interpolate`.</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_size: expected shape of spatial dimensions after resize operation.</span>
<span class="sd">            if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">            corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">            to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">        mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">            The interpolation mode. Defaults to ``&quot;area&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">        align_corners: This only has an effect when mode is</span>
<span class="sd">            &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Default: None.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">InterpolateMode</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">align_corners</span>

<div class="viewcode-block" id="Resize.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resize.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: (num_channels, H[, W, ..., ]).</span>
<span class="sd">            mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">                The interpolation mode. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            align_corners: This only has an effect when mode is</span>
<span class="sd">                &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Defaults to ``self.align_corners``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When ``self.spatial_size`` length is less than ``img`` spatial dimensions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_ndim</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># spatial ndim</span>
        <span class="n">output_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_ndim</span> <span class="o">&gt;</span> <span class="n">input_ndim</span><span class="p">:</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">ensure_tuple_size</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">output_ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output_ndim</span> <span class="o">&lt;</span> <span class="n">input_ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;len(spatial_size) must be greater or equal to img spatial dimensions, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got spatial_size=</span><span class="si">{</span><span class="n">output_ndim</span><span class="si">}</span><span class="s2"> img=</span><span class="si">{</span><span class="n">input_ndim</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="n">spatial_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">resized</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="nb">input</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">size</span><span class="o">=</span><span class="n">spatial_size</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">InterpolateMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">align_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">resized</span> <span class="o">=</span> <span class="n">resized</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">resized</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Rotate"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate">[docs]</a><span class="k">class</span> <span class="nc">Rotate</span><span class="p">(</span><span class="n">Transform</span><span class="p">,</span> <span class="n">ThreadUnsafe</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotates an input image by given angle using :py:class:`monai.networks.layers.AffineTransform`.</span>

<span class="sd">    Args:</span>
<span class="sd">        angle: Rotation angle(s) in radians. should a float for 2D, three floats for 3D.</span>
<span class="sd">        keep_size: If it is True, the output shape is kept the same as the input.</span>
<span class="sd">            If it is False, the output shape is adapted so that the</span>
<span class="sd">            input array is contained completely in the output. Default is True.</span>
<span class="sd">        mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">            Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">            Padding mode for outside grid values. Defaults to ``&quot;border&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        align_corners: Defaults to False.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        dtype: data type for resampling computation. Defaults to ``np.float64`` for best precision.</span>
<span class="sd">            If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">            the output data type is always ``np.float32``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">angle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">BORDER</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="o">=</span> <span class="n">keep_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">align_corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Rotate.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: [chns, H, W] or [chns, H, W, D].</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">                align_corners: Defaults to ``self.align_corners``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            align_corners: Defaults to ``self.align_corners``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            dtype: data type for resampling computation. Defaults to ``self.dtype``.</span>
<span class="sd">                If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">                the output data type is always ``np.float32``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When ``img`` spatially is not one of [2D, 3D].</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">im_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># spatial dimensions</span>
        <span class="n">input_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported img dimension: </span><span class="si">{</span><span class="n">input_ndim</span><span class="si">}</span><span class="s2">, available options are [2, 3].&quot;</span><span class="p">)</span>
        <span class="n">_angle</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">input_ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">create_rotate</span><span class="p">(</span><span class="n">input_ndim</span><span class="p">,</span> <span class="n">_angle</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">create_translate</span><span class="p">(</span><span class="n">input_ndim</span><span class="p">,</span> <span class="p">((</span><span class="n">im_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">:</span>
            <span class="n">output_shape</span> <span class="o">=</span> <span class="n">im_shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">im_shape</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">im_shape</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">corners</span>
            <span class="n">output_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">corners</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">shift_1</span> <span class="o">=</span> <span class="n">create_translate</span><span class="p">(</span><span class="n">input_ndim</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">output_shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">@</span> <span class="n">transform</span> <span class="o">@</span> <span class="n">shift_1</span>

        <span class="n">xform</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span>
            <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span>
            <span class="n">align_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
            <span class="n">reverse_indexing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">xform</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">)),</span>
            <span class="n">spatial_size</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_matrix</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rotate.get_rotation_matrix"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate.get_rotation_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the most recently applied rotation matrix</span>
<span class="sd">        This is not thread-safe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_matrix</span></div></div>


<div class="viewcode-block" id="Zoom"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Zoom">[docs]</a><span class="k">class</span> <span class="nc">Zoom</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zooms an ND image using :py:class:`torch.nn.functional.interpolate`.</span>
<span class="sd">    For details, please see https://pytorch.org/docs/stable/nn.functional.html#interpolate.</span>

<span class="sd">    Different from :py:class:`monai.transforms.resize`, this transform takes scaling factors</span>
<span class="sd">    as input, and provides an option of preserving the input spatial size.</span>

<span class="sd">    Args:</span>
<span class="sd">        zoom: The zoom factor along the spatial axes.</span>
<span class="sd">            If a float, zoom is the same for each spatial axis.</span>
<span class="sd">            If a sequence, zoom should contain one value for each spatial axis.</span>
<span class="sd">        mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">            The interpolation mode. Defaults to ``&quot;area&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">        padding_mode: {``&quot;constant&quot;``, ``&quot;edge``&quot;, ``&quot;linear_ramp``&quot;, ``&quot;maximum``&quot;, ``&quot;mean``&quot;, `&quot;median``&quot;,</span>
<span class="sd">            ``&quot;minimum``&quot;, `&quot;reflect``&quot;, ``&quot;symmetric``&quot;, ``&quot;wrap``&quot;, ``&quot;empty``&quot;, ``&quot;&lt;function&gt;``&quot;}</span>
<span class="sd">            The mode to pad data after zooming.</span>
<span class="sd">            See also: https://numpy.org/doc/stable/reference/generated/numpy.pad.html</span>
<span class="sd">        align_corners: This only has an effect when mode is</span>
<span class="sd">            &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Default: None.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">        keep_size: Should keep original size (padding/slicing if needed), default is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">zoom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NumpyPadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">NumpyPadMode</span><span class="o">.</span><span class="n">EDGE</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zoom</span> <span class="o">=</span> <span class="n">zoom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">InterpolateMode</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">NumpyPadMode</span> <span class="o">=</span> <span class="n">NumpyPadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">align_corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="o">=</span> <span class="n">keep_size</span>

<div class="viewcode-block" id="Zoom.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Zoom.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">NumpyPadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: (num_channels, H[, W, ..., ]).</span>
<span class="sd">            mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">                The interpolation mode. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            padding_mode: {``&quot;constant&quot;``, ``&quot;edge``&quot;, ``&quot;linear_ramp``&quot;, ``&quot;maximum``&quot;, ``&quot;mean``&quot;, `&quot;median``&quot;,</span>
<span class="sd">                ``&quot;minimum``&quot;, `&quot;reflect``&quot;, ``&quot;symmetric``&quot;, ``&quot;wrap``&quot;, ``&quot;empty``&quot;, ``&quot;&lt;function&gt;``&quot;}</span>
<span class="sd">                The mode to pad data after zooming, default to ``self.padding_mode``.</span>
<span class="sd">                See also: https://numpy.org/doc/stable/reference/generated/numpy.pad.html</span>
<span class="sd">            align_corners: This only has an effect when mode is</span>
<span class="sd">                &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Defaults to ``self.align_corners``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoom</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># match the spatial image dim</span>
        <span class="n">zoomed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="n">recompute_scale_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">scale_factor</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">_zoom</span><span class="p">),</span>
            <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">InterpolateMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">align_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">zoomed</span> <span class="o">=</span> <span class="n">zoomed</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">zoomed</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">zoomed</span>

        <span class="n">pad_vec</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">slice_vec</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">zd</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">zoomed</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">od</span> <span class="o">-</span> <span class="n">zd</span>
            <span class="n">half</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># need padding</span>
                <span class="n">pad_vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">half</span><span class="p">,</span> <span class="n">diff</span> <span class="o">-</span> <span class="n">half</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># need slicing</span>
                <span class="n">slice_vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">half</span><span class="p">,</span> <span class="n">half</span> <span class="o">+</span> <span class="n">od</span><span class="p">)</span>

        <span class="n">padding_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span> <span class="k">if</span> <span class="n">padding_mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">NumpyPadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="n">zoomed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">zoomed</span><span class="p">,</span> <span class="n">pad_vec</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zoomed</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice_vec</span><span class="p">)]</span></div></div>


<div class="viewcode-block" id="Rotate90"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate90">[docs]</a><span class="k">class</span> <span class="nc">Rotate90</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate an array by 90 degrees in the plane specified by `axes`.</span>
<span class="sd">    See np.rot90 for additional details:</span>
<span class="sd">    https://numpy.org/doc/stable/reference/generated/numpy.rot90.html.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Rotate90.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate90.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spatial_axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            k: number of times to rotate by 90 degrees.</span>
<span class="sd">            spatial_axes: 2 int numbers, defines the plane to rotate with 2 spatial axes.</span>
<span class="sd">                Default: (0, 1), this is the first two axis in spatial dimensions.</span>
<span class="sd">                If axis is negative it counts from the last to the first axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">spatial_axes_</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">spatial_axes</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_axes_</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;spatial_axes must be 2 int numbers to indicate the axes to rotate 90 degrees.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span> <span class="o">=</span> <span class="n">spatial_axes_</span></div>

<div class="viewcode-block" id="Rotate90.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rotate90.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: (num_channels, H[, W, ..., ]),</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">map_spatial_axes</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandRotate90"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90">[docs]</a><span class="k">class</span> <span class="nc">RandRotate90</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    With probability `prob`, input arrays are rotated by 90 degrees</span>
<span class="sd">    in the plane specified by `spatial_axes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandRotate90.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">max_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">spatial_axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            prob: probability of rotating.</span>
<span class="sd">                (Default 0.1, with 10% probability it returns a rotated array)</span>
<span class="sd">            max_k: number of rotations will be sampled from `np.random.randint(max_k) + 1`, (Default 3).</span>
<span class="sd">            spatial_axes: 2 int numbers, defines the plane to rotate with 2 spatial axes.</span>
<span class="sd">                Default: (0, 1), this is the first two axis in spatial dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_k</span> <span class="o">=</span> <span class="n">max_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span> <span class="o">=</span> <span class="n">spatial_axes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rand_k</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="RandRotate90.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rand_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandRotate90.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate90.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: (num_channels, H[, W, ..., ]),</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">rotator</span> <span class="o">=</span> <span class="n">Rotate90</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rand_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotator</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandRotate"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate">[docs]</a><span class="k">class</span> <span class="nc">RandRotate</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly rotate the input arrays.</span>

<span class="sd">    Args:</span>
<span class="sd">        range_x: Range of rotation angle in radians in the plane defined by the first and second axes.</span>
<span class="sd">            If single number, angle is uniformly sampled from (-range_x, range_x).</span>
<span class="sd">        range_y: Range of rotation angle in radians in the plane defined by the first and third axes.</span>
<span class="sd">            If single number, angle is uniformly sampled from (-range_y, range_y).</span>
<span class="sd">        range_z: Range of rotation angle in radians in the plane defined by the second and third axes.</span>
<span class="sd">            If single number, angle is uniformly sampled from (-range_z, range_z).</span>
<span class="sd">        prob: Probability of rotation.</span>
<span class="sd">        keep_size: If it is False, the output shape is adapted so that the</span>
<span class="sd">            input array is contained completely in the output.</span>
<span class="sd">            If it is True, the output shape is the same as the input. Default is True.</span>
<span class="sd">        mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">            Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">            Padding mode for outside grid values. Defaults to ``&quot;border&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        align_corners: Defaults to False.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        dtype: data type for resampling computation. Defaults to ``np.float64`` for best precision.</span>
<span class="sd">            If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">            the output data type is always ``np.float32``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">range_x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">range_y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">range_z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">BORDER</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_x</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">range_x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_y</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">range_y</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_y</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_z</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">range_z</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_z</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="o">=</span> <span class="n">keep_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">align_corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span>

<div class="viewcode-block" id="RandRotate.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="RandRotate.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandRotate.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape 2D: (nchannels, H, W), or 3D: (nchannels, H, W, D).</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            align_corners: Defaults to ``self.align_corners``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            dtype: data type for resampling computation. Defaults to ``self.dtype``.</span>
<span class="sd">                If None, use the data type of input data. To be compatible with other modules,</span>
<span class="sd">                the output data type is always ``np.float32``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">rotator</span> <span class="o">=</span> <span class="n">Rotate</span><span class="p">(</span>
            <span class="n">angle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">),</span>
            <span class="n">keep_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span>
            <span class="n">align_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotator</span><span class="p">(</span><span class="n">img</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="RandFlip"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandFlip">[docs]</a><span class="k">class</span> <span class="nc">RandFlip</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly flips the image along axes. Preserves shape.</span>
<span class="sd">    See numpy.flip for additional details.</span>
<span class="sd">    https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html</span>

<span class="sd">    Args:</span>
<span class="sd">        prob: Probability of flipping.</span>
<span class="sd">        spatial_axis: Spatial axes along which to flip over. Default is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span> <span class="o">=</span> <span class="n">Flip</span><span class="p">(</span><span class="n">spatial_axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">)</span>

<div class="viewcode-block" id="RandFlip.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandFlip.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: (num_channels, H[, W, ..., ]),</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipper</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandAxisFlip"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAxisFlip">[docs]</a><span class="k">class</span> <span class="nc">RandAxisFlip</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly select a spatial axis and flip along it.</span>
<span class="sd">    See numpy.flip for additional details.</span>
<span class="sd">    https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html</span>

<span class="sd">    Args:</span>
<span class="sd">        prob: Probability of flipping.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="RandAxisFlip.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAxisFlip.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandAxisFlip.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAxisFlip.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape: (num_channels, H[, W, ..., ]),</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">img</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">flipper</span> <span class="o">=</span> <span class="n">Flip</span><span class="p">(</span><span class="n">spatial_axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flipper</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandZoom"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandZoom">[docs]</a><span class="k">class</span> <span class="nc">RandZoom</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly zooms input arrays with given probability within given zoom range.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob: Probability of zooming.</span>
<span class="sd">        min_zoom: Min zoom factor. Can be float or sequence same size as image.</span>
<span class="sd">            If a float, select a random factor from `[min_zoom, max_zoom]` then apply to all spatial dims</span>
<span class="sd">            to keep the original spatial shape ratio.</span>
<span class="sd">            If a sequence, min_zoom should contain one value for each spatial axis.</span>
<span class="sd">            If 2 values provided for 3D data, use the first value for both H &amp; W dims to keep the same zoom ratio.</span>
<span class="sd">        max_zoom: Max zoom factor. Can be float or sequence same size as image.</span>
<span class="sd">            If a float, select a random factor from `[min_zoom, max_zoom]` then apply to all spatial dims</span>
<span class="sd">            to keep the original spatial shape ratio.</span>
<span class="sd">            If a sequence, max_zoom should contain one value for each spatial axis.</span>
<span class="sd">            If 2 values provided for 3D data, use the first value for both H &amp; W dims to keep the same zoom ratio.</span>
<span class="sd">        mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">            The interpolation mode. Defaults to ``&quot;area&quot;``.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">        padding_mode: {``&quot;constant&quot;``, ``&quot;edge``&quot;, ``&quot;linear_ramp``&quot;, ``&quot;maximum``&quot;, ``&quot;mean``&quot;, `&quot;median``&quot;,</span>
<span class="sd">            ``&quot;minimum``&quot;, `&quot;reflect``&quot;, ``&quot;symmetric``&quot;, ``&quot;wrap``&quot;, ``&quot;empty``&quot;, ``&quot;&lt;function&gt;``&quot;}</span>
<span class="sd">            The mode to pad data after zooming.</span>
<span class="sd">            See also: https://numpy.org/doc/stable/reference/generated/numpy.pad.html</span>
<span class="sd">        align_corners: This only has an effect when mode is</span>
<span class="sd">            &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Default: None.</span>
<span class="sd">            See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">        keep_size: Should keep original size (pad if needed), default is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">min_zoom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">max_zoom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="o">.</span><span class="n">AREA</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NumpyPadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">NumpyPadMode</span><span class="o">.</span><span class="n">EDGE</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">min_zoom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">max_zoom</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_zoom</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_zoom</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;min_zoom and max_zoom must have same length.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">InterpolateMode</span> <span class="o">=</span> <span class="n">InterpolateMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">NumpyPadMode</span> <span class="o">=</span> <span class="n">NumpyPadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="o">=</span> <span class="n">align_corners</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="o">=</span> <span class="n">keep_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>

<div class="viewcode-block" id="RandZoom.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandZoom.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_zoom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_zoom</span><span class="p">)]</span></div>

<div class="viewcode-block" id="RandZoom.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandZoom.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">InterpolateMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">NumpyPadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: channel first array, must have shape 2D: (nchannels, H, W), or 3D: (nchannels, H, W, D).</span>
<span class="sd">            mode: {``&quot;nearest&quot;``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;bicubic&quot;``, ``&quot;trilinear&quot;``, ``&quot;area&quot;``}</span>
<span class="sd">                The interpolation mode. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">            padding_mode: {``&quot;constant&quot;``, ``&quot;edge``&quot;, ``&quot;linear_ramp``&quot;, ``&quot;maximum``&quot;, ``&quot;mean``&quot;, `&quot;median``&quot;,</span>
<span class="sd">                ``&quot;minimum``&quot;, `&quot;reflect``&quot;, ``&quot;symmetric``&quot;, ``&quot;wrap``&quot;, ``&quot;empty``&quot;, ``&quot;&lt;function&gt;``&quot;}</span>
<span class="sd">                The mode to pad data after zooming, default to ``self.padding_mode``.</span>
<span class="sd">                See also: https://numpy.org/doc/stable/reference/generated/numpy.pad.html</span>
<span class="sd">            align_corners: This only has an effect when mode is</span>
<span class="sd">                &#39;linear&#39;, &#39;bilinear&#39;, &#39;bicubic&#39; or &#39;trilinear&#39;. Defaults to ``self.align_corners``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#interpolate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># match the spatial image dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="n">_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># to keep the spatial shape ratio, use same random zoom factor for all dims</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># if 2 zoom factors provided for 3D data, use the first factor for H and W dims, second factor for D dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">zoomer</span> <span class="o">=</span> <span class="n">Zoom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zoom</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">zoomer</span><span class="p">(</span>
                <span class="n">img</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_corners</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">align_corners</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">_dtype</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="AffineGrid"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AffineGrid">[docs]</a><span class="k">class</span> <span class="nc">AffineGrid</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Affine transforms on the coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        rotate_params: angle range in radians. rotate_params[0] with be used to generate the 1st rotation</span>
<span class="sd">            parameter from `uniform[-rotate_params[0], rotate_params[0])`. Similarly, `rotate_params[1]` and</span>
<span class="sd">            `rotate_params[2]` are used in 3D affine for the range of 2nd and 3rd axes.</span>
<span class="sd">        shear_params: shear_params[0] with be used to generate the 1st shearing parameter from</span>
<span class="sd">            `uniform[-shear_params[0], shear_params[0])`. Similarly, `shear_params[1]` to</span>
<span class="sd">            `shear_params[N]` controls the range of the uniform distribution used to generate the 2nd to</span>
<span class="sd">            N-th parameter.</span>
<span class="sd">        translate_params : translate_params[0] with be used to generate the 1st shift parameter from</span>
<span class="sd">            `uniform[-translate_params[0], translate_params[0])`. Similarly, `translate_params[1]`</span>
<span class="sd">            to `translate_params[N]` controls the range of the uniform distribution used to generate</span>
<span class="sd">            the 2nd to N-th parameter.</span>
<span class="sd">        scale_params: scale_params[0] with be used to generate the 1st scaling factor from</span>
<span class="sd">            `uniform[-scale_params[0], scale_params[0]) + 1.0`. Similarly, `scale_params[1]` to</span>
<span class="sd">            `scale_params[N]` controls the range of the uniform distribution used to generate the 2nd to</span>
<span class="sd">            N-th parameter.</span>
<span class="sd">        as_tensor_output: whether to output tensor instead of numpy array.</span>
<span class="sd">            defaults to True.</span>
<span class="sd">        device: device to store the output grid data.</span>
<span class="sd">        affine: If applied, ignore the params (`rotate_params`, etc.) and use the</span>
<span class="sd">            supplied matrix. Should be square with each side = num of image spatial</span>
<span class="sd">            dimensions + 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">affine</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate_params</span> <span class="o">=</span> <span class="n">rotate_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shear_params</span> <span class="o">=</span> <span class="n">shear_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate_params</span> <span class="o">=</span> <span class="n">translate_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_params</span> <span class="o">=</span> <span class="n">scale_params</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span>

<div class="viewcode-block" id="AffineGrid.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AffineGrid.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spatial_size: output grid size.</span>
<span class="sd">            grid: grid to be transformed. Shape must be (3, H, W) for 2D or (4, H, W, D) for 3D.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When ``grid=None`` and ``spatial_size=None``. Incompatible values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spatial_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible values: grid=None and spatial_size=None.&quot;</span><span class="p">)</span>

        <span class="n">affine</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spatial_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_params</span><span class="p">:</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span> <span class="o">@</span> <span class="n">create_rotate</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_params</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear_params</span><span class="p">:</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span> <span class="o">@</span> <span class="n">create_shear</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear_params</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate_params</span><span class="p">:</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span> <span class="o">@</span> <span class="n">create_translate</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate_params</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_params</span><span class="p">:</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span> <span class="o">@</span> <span class="n">create_scale</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">affine</span><span class="p">))</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">grid</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">affine</span><span class="o">.</span><span class="n">float</span><span class="p">()</span> <span class="o">@</span> <span class="n">grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown grid.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()),</span> <span class="n">affine</span></div></div>


<div class="viewcode-block" id="RandAffineGrid"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffineGrid">[docs]</a><span class="k">class</span> <span class="nc">RandAffineGrid</span><span class="p">(</span><span class="n">Randomizable</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate randomised affine grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandAffineGrid.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffineGrid.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            rotate_range: angle range in radians. If element `i` is iterable, then</span>
<span class="sd">                `uniform[-rotate_range[i][0], rotate_range[i][1])` will be used to generate the rotation parameter</span>
<span class="sd">                for the ith dimension. If not, `uniform[-rotate_range[i], rotate_range[i])` will be used. This can</span>
<span class="sd">                be altered on a per-dimension basis. E.g., `((0,3), 1, ...)`: for dim0, rotation will be in range</span>
<span class="sd">                `[0, 3]`, and for dim1 `[-1, 1]` will be used. Setting a single value will use `[-x, x]` for dim0</span>
<span class="sd">                and nothing for the remaining dimensions.</span>
<span class="sd">            shear_range: shear_range with format matching `rotate_range`.</span>
<span class="sd">            translate_range: translate_range with format matching `rotate_range`.</span>
<span class="sd">            scale_range: scaling_range with format matching `rotate_range`. A value of 1.0 is added to the result.</span>
<span class="sd">                This allows 0 to correspond to no change (i.e., a scaling of 1).</span>
<span class="sd">            as_tensor_output: whether to output tensor instead of numpy array.</span>
<span class="sd">                defaults to True.</span>
<span class="sd">            device: device to store the output grid data.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:meth:`monai.transforms.utils.create_rotate`</span>
<span class="sd">            - :py:meth:`monai.transforms.utils.create_shear`</span>
<span class="sd">            - :py:meth:`monai.transforms.utils.create_translate`</span>
<span class="sd">            - :py:meth:`monai.transforms.utils.create_scale`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate_range</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">rotate_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shear_range</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">shear_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate_range</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">translate_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_range</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">scale_range</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shear_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_get_rand_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_range</span><span class="p">,</span> <span class="n">add_scalar</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="n">out_param</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">param_range</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">issequenceiterable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If giving range as [min,max], should only have two elements per dim.&quot;</span><span class="p">)</span>
                <span class="n">out_param</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">add_scalar</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out_param</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">add_scalar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_param</span>

<div class="viewcode-block" id="RandAffineGrid.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffineGrid.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rand_param</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotate_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shear_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rand_param</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rand_param</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translate_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rand_param</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_range</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandAffineGrid.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffineGrid.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spatial_size: output grid size.</span>
<span class="sd">            grid: grid to be transformed. Shape must be (3, H, W) for 2D or (4, H, W, D) for 3D.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a 2D (3xHxW) or 3D (4xHxWxD) grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="n">affine_grid</span> <span class="o">=</span> <span class="n">AffineGrid</span><span class="p">(</span>
            <span class="n">rotate_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotate_params</span><span class="p">,</span>
            <span class="n">shear_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shear_params</span><span class="p">,</span>
            <span class="n">translate_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translate_params</span><span class="p">,</span>
            <span class="n">scale_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_params</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span> <span class="o">=</span> <span class="n">affine_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span></div>

<div class="viewcode-block" id="RandAffineGrid.get_transformation_matrix"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffineGrid.get_transformation_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get the most recently applied transformation matrix&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span></div></div>


<div class="viewcode-block" id="RandDeformGrid"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandDeformGrid">[docs]</a><span class="k">class</span> <span class="nc">RandDeformGrid</span><span class="p">(</span><span class="n">Randomizable</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random deformation grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandDeformGrid.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandDeformGrid.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spacing</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">magnitude_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spacing: spacing of the grid in 2D or 3D.</span>
<span class="sd">                e.g., spacing=(1, 1) indicates pixel-wise deformation in 2D,</span>
<span class="sd">                spacing=(1, 1, 1) indicates voxel-wise deformation in 3D,</span>
<span class="sd">                spacing=(2, 2) indicates deformation field defined on every other pixel in 2D.</span>
<span class="sd">            magnitude_range: the random offsets will be generated from</span>
<span class="sd">                `uniform[magnitude[0], magnitude[1])`.</span>
<span class="sd">            as_tensor_output: whether to output tensor instead of numpy array.</span>
<span class="sd">                defaults to True.</span>
<span class="sd">            device: device to store the output grid data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="n">spacing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="n">magnitude_range</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rand_mag</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_offset</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span></div>

<div class="viewcode-block" id="RandDeformGrid.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandDeformGrid.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_mag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="RandDeformGrid.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandDeformGrid.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spatial_size: spatial size of the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">))</span>
        <span class="n">control_grid</span> <span class="o">=</span> <span class="n">create_control_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">control_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">control_grid</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">)]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_mag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_offset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span><span class="p">:</span>
            <span class="n">control_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">control_grid</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">control_grid</span></div></div>


<div class="viewcode-block" id="Resample"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resample">[docs]</a><span class="k">class</span> <span class="nc">Resample</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
<div class="viewcode-block" id="Resample.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resample.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">BORDER</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        computes output image using values from `img`, locations from `grid` using pytorch.</span>
<span class="sd">        supports spatially 2D or 3D (num_channels, H, W[, D]).</span>

<span class="sd">        Args:</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;border&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            as_tensor_output: whether to return a torch tensor. Defaults to False.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span></div>

<div class="viewcode-block" id="Resample.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Resample.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: shape must be (num_channels, H, W[, D]).</span>
<span class="sd">            grid: shape must be (3, H, W) for 2D or (4, H, W, D) for 3D.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Error, grid argument must be supplied as an ndarray or tensor &quot;</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">grid</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">USE_COMPILED</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()))[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">_padding_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">padding_mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">_padding_mode</span> <span class="o">==</span> <span class="s2">&quot;zeros&quot;</span><span class="p">:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="mi">7</span>
            <span class="k">elif</span> <span class="n">_padding_mode</span> <span class="o">==</span> <span class="s2">&quot;border&quot;</span><span class="p">:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">_interp_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">grid_pull</span><span class="p">(</span>
                <span class="n">img</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
                <span class="n">grid</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
                <span class="n">bound</span><span class="o">=</span><span class="n">bound</span><span class="p">,</span>
                <span class="n">extrapolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">_interp_mode</span> <span class="o">==</span> <span class="s2">&quot;bilinear&quot;</span> <span class="k">else</span> <span class="n">_interp_mode</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">index_ordering</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">index_ordering</span><span class="p">]</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()))[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">grid_sample</span><span class="p">(</span>
                <span class="n">img</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
                <span class="n">grid</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
                <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">padding_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">padding_mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span></div></div>


<div class="viewcode-block" id="Affine"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Affine">[docs]</a><span class="k">class</span> <span class="nc">Affine</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform ``img`` given the affine parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Affine.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Affine.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rotate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">image_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The affine transformations are applied in rotate, shear, translate, scale order.</span>

<span class="sd">        Args:</span>
<span class="sd">            rotate_params: a rotation angle in radians, a scalar for 2D image, a tuple of 3 floats for 3D.</span>
<span class="sd">                Defaults to no rotation.</span>
<span class="sd">            shear_params: a tuple of 2 floats for 2D, a tuple of 6 floats for 3D. Defaults to no shearing.</span>
<span class="sd">            translate_params: a tuple of 2 floats for 2D, a tuple of 3 floats for 3D. Translation is in</span>
<span class="sd">                pixel/voxel relative to the center of the input image. Defaults to no translation.</span>
<span class="sd">            scale_params: a tuple of 2 floats for 2D, a tuple of 3 floats for 3D. Defaults to no scaling.</span>
<span class="sd">            spatial_size: output image spatial size.</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">                to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>
<span class="sd">            image_only: if True return only the image volume, otherwise return (image, affine).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">affine_grid</span> <span class="o">=</span> <span class="n">AffineGrid</span><span class="p">(</span>
            <span class="n">rotate_params</span><span class="o">=</span><span class="n">rotate_params</span><span class="p">,</span>
            <span class="n">shear_params</span><span class="o">=</span><span class="n">shear_params</span><span class="p">,</span>
            <span class="n">translate_params</span><span class="o">=</span><span class="n">translate_params</span><span class="p">,</span>
            <span class="n">scale_params</span><span class="o">=</span><span class="n">scale_params</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_only</span> <span class="o">=</span> <span class="n">image_only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span> <span class="o">=</span> <span class="n">Resample</span><span class="p">(</span><span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span> <span class="o">=</span> <span class="n">spatial_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Affine.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: shape must be (num_channels, H, W[, D]),</span>
<span class="sd">            spatial_size: output image spatial size.</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if `img` has two spatial dimensions, `spatial_size` should have 2 elements [h, w].</span>
<span class="sd">                if `img` has three spatial dimensions, `spatial_size` should have 3 elements [h, w, d].</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">spatial_size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">grid</span><span class="p">,</span> <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_only</span> <span class="k">else</span> <span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandAffine"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffine">[docs]</a><span class="k">class</span> <span class="nc">RandAffine</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random affine transform.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandAffine.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffine.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rotate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">cache_grid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            prob: probability of returning a randomized affine grid.</span>
<span class="sd">                defaults to 0.1, with 10% chance returns a randomized grid.</span>
<span class="sd">            rotate_range: angle range in radians. If element `i` is iterable, then</span>
<span class="sd">                `uniform[-rotate_range[i][0], rotate_range[i][1])` will be used to generate the rotation parameter</span>
<span class="sd">                for the ith dimension. If not, `uniform[-rotate_range[i], rotate_range[i])` will be used. This can</span>
<span class="sd">                be altered on a per-dimension basis. E.g., `((0,3), 1, ...)`: for dim0, rotation will be in range</span>
<span class="sd">                `[0, 3]`, and for dim1 `[-1, 1]` will be used. Setting a single value will use `[-x, x]` for dim0</span>
<span class="sd">                and nothing for the remaining dimensions.</span>
<span class="sd">            shear_range: shear_range with format matching `rotate_range`.</span>
<span class="sd">            translate_range: translate_range with format matching `rotate_range`.</span>
<span class="sd">            scale_range: scaling_range with format matching `rotate_range`. A value of 1.0 is added to the result.</span>
<span class="sd">                This allows 0 to correspond to no change (i.e., a scaling of 1).</span>
<span class="sd">            spatial_size: output image spatial size.</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">                to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            cache_grid: whether to cache the identity sampling grid.</span>
<span class="sd">                If the spatial size is not dynamically defined by input image, enabling this option could</span>
<span class="sd">                accelerate the transform.</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:class:`RandAffineGrid` for the random affine parameters configurations.</span>
<span class="sd">            - :py:class:`Affine` for the affine transformation parameters configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span> <span class="o">=</span> <span class="n">RandAffineGrid</span><span class="p">(</span>
            <span class="n">rotate_range</span><span class="o">=</span><span class="n">rotate_range</span><span class="p">,</span>
            <span class="n">shear_range</span><span class="o">=</span><span class="n">shear_range</span><span class="p">,</span>
            <span class="n">translate_range</span><span class="o">=</span><span class="n">translate_range</span><span class="p">,</span>
            <span class="n">scale_range</span><span class="o">=</span><span class="n">scale_range</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span> <span class="o">=</span> <span class="n">Resample</span><span class="p">(</span><span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span> <span class="o">=</span> <span class="n">spatial_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_grid</span> <span class="o">=</span> <span class="n">cache_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_identity_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_init_identity_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create cache of the identity grid if cache_grid=True and spatial_size is known.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_grid</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;cache_grid=True is not compatible with the dynamic spatial_size, please specify &#39;spatial_size&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">_sp_size</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">)</span>
        <span class="n">_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_sp_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_sp_size</span> <span class="o">!=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">_sp_size</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">_ndim</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_sp_size</span> <span class="o">!=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">_sp_size</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">_ndim</span><span class="p">):</span>
            <span class="c1"># dynamic shape because it falls back to different outcomes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_grid</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;cache_grid=True is not compatible with the dynamic spatial_size &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;spatial_size=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="si">}</span><span class="s2">&#39;, please specify &#39;spatial_size&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">create_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">_sp_size</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

<div class="viewcode-block" id="RandAffine.get_identity_grid"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffine.get_identity_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_identity_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a cached or new identity grid depends on the availability.</span>

<span class="sd">        Args:</span>
<span class="sd">            spatial_size: non-dynamic spatial size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spatial_size</span> <span class="o">!=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">)</span> <span class="ow">or</span> <span class="n">spatial_size</span> <span class="o">!=</span> <span class="n">fall_back_tuple</span><span class="p">(</span>
            <span class="n">spatial_size</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spatial_size should not be dynamic, got </span><span class="si">{</span><span class="n">spatial_size</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">spatial_size</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_grid</span></div>

<div class="viewcode-block" id="RandAffine.set_random_state"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffine.set_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_random_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;RandAffine&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="RandAffine.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffine.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span></div>

<div class="viewcode-block" id="RandAffine.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAffine.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: shape must be (num_channels, H, W[, D]),</span>
<span class="sd">            spatial_size: output image spatial size.</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if `img` has two spatial dimensions, `spatial_size` should have 2 elements [h, w].</span>
<span class="sd">                if `img` has three spatial dimensions, `spatial_size` should have 3 elements [h, w, d].</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="c1"># if not doing transform and spatial size doesn&#39;t change, nothing to do</span>
        <span class="c1"># except convert to float and convert numpy/torch</span>
        <span class="n">sp_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">spatial_size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">do_resampling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sp_size</span> <span class="o">!=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_resampling</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">float</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_identity_grid</span><span class="p">(</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span>
            <span class="n">img</span><span class="o">=</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="Rand2DElastic"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElastic">[docs]</a><span class="k">class</span> <span class="nc">Rand2DElastic</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random elastic deformation and affine in 2D</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Rand2DElastic.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElastic.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spacing</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">magnitude_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rotate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spacing : distance in between the control points.</span>
<span class="sd">            magnitude_range: the random offsets will be generated from ``uniform[magnitude[0], magnitude[1])``.</span>
<span class="sd">            prob: probability of returning a randomized elastic transform.</span>
<span class="sd">                defaults to 0.1, with 10% chance returns a randomized elastic transform,</span>
<span class="sd">                otherwise returns a ``spatial_size`` centered area extracted from the input image.</span>
<span class="sd">            rotate_range: angle range in radians. If element `i` is iterable, then</span>
<span class="sd">                `uniform[-rotate_range[i][0], rotate_range[i][1])` will be used to generate the rotation parameter</span>
<span class="sd">                for the ith dimension. If not, `uniform[-rotate_range[i], rotate_range[i])` will be used. This can</span>
<span class="sd">                be altered on a per-dimension basis. E.g., `((0,3), 1, ...)`: for dim0, rotation will be in range</span>
<span class="sd">                `[0, 3]`, and for dim1 `[-1, 1]` will be used. Setting a single value will use `[-x, x]` for dim0</span>
<span class="sd">                and nothing for the remaining dimensions.</span>
<span class="sd">            shear_range: shear_range with format matching `rotate_range`.</span>
<span class="sd">            translate_range: translate_range with format matching `rotate_range`.</span>
<span class="sd">            scale_range: scaling_range with format matching `rotate_range`. A value of 1.0 is added to the result.</span>
<span class="sd">                This allows 0 to correspond to no change (i.e., a scaling of 1).</span>
<span class="sd">            spatial_size: specifying output image spatial size [h, w].</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, -1)` will be adapted</span>
<span class="sd">                to `(32, 64)` if the second spatial dimension size of img is `64`.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:class:`RandAffineGrid` for the random affine parameters configurations.</span>
<span class="sd">            - :py:class:`Affine` for the affine transformation parameters configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deform_grid</span> <span class="o">=</span> <span class="n">RandDeformGrid</span><span class="p">(</span>
            <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">magnitude_range</span><span class="o">=</span><span class="n">magnitude_range</span><span class="p">,</span> <span class="n">as_tensor_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span> <span class="o">=</span> <span class="n">RandAffineGrid</span><span class="p">(</span>
            <span class="n">rotate_range</span><span class="o">=</span><span class="n">rotate_range</span><span class="p">,</span>
            <span class="n">shear_range</span><span class="o">=</span><span class="n">shear_range</span><span class="p">,</span>
            <span class="n">translate_range</span><span class="o">=</span><span class="n">translate_range</span><span class="p">,</span>
            <span class="n">scale_range</span><span class="o">=</span><span class="n">scale_range</span><span class="p">,</span>
            <span class="n">as_tensor_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span> <span class="o">=</span> <span class="n">Resample</span><span class="p">(</span><span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span> <span class="o">=</span> <span class="n">spatial_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rand2DElastic.set_random_state"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElastic.set_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_random_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Rand2DElastic&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deform_grid</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Rand2DElastic.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElastic.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deform_grid</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span></div>

<div class="viewcode-block" id="Rand2DElastic.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand2DElastic.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: shape must be (num_channels, H, W),</span>
<span class="sd">            spatial_size: specifying output image spatial size [h, w].</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">spatial_size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deform_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="n">recompute_scale_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="nb">input</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">scale_factor</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">ensure_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deform_grid</span><span class="o">.</span><span class="n">spacing</span><span class="p">)),</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">InterpolateMode</span><span class="o">.</span><span class="n">BICUBIC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">CenterSpatialCrop</span><span class="p">(</span><span class="n">roi_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Rand3DElastic"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElastic">[docs]</a><span class="k">class</span> <span class="nc">Rand3DElastic</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random elastic deformation and affine in 3D</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Rand3DElastic.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElastic.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">magnitude_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">rotate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shear_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">translate_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_range</span><span class="p">:</span> <span class="n">RandRange</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="o">.</span><span class="n">BILINEAR</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="o">.</span><span class="n">REFLECTION</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            sigma_range: a Gaussian kernel with standard deviation sampled from</span>
<span class="sd">                ``uniform[sigma_range[0], sigma_range[1])`` will be used to smooth the random offset grid.</span>
<span class="sd">            magnitude_range: the random offsets on the grid will be generated from</span>
<span class="sd">                ``uniform[magnitude[0], magnitude[1])``.</span>
<span class="sd">            prob: probability of returning a randomized elastic transform.</span>
<span class="sd">                defaults to 0.1, with 10% chance returns a randomized elastic transform,</span>
<span class="sd">                otherwise returns a ``spatial_size`` centered area extracted from the input image.</span>
<span class="sd">            rotate_range: angle range in radians. If element `i` is iterable, then</span>
<span class="sd">                `uniform[-rotate_range[i][0], rotate_range[i][1])` will be used to generate the rotation parameter</span>
<span class="sd">                for the ith dimension. If not, `uniform[-rotate_range[i], rotate_range[i])` will be used. This can</span>
<span class="sd">                be altered on a per-dimension basis. E.g., `((0,3), 1, ...)`: for dim0, rotation will be in range</span>
<span class="sd">                `[0, 3]`, and for dim1 `[-1, 1]` will be used. Setting a single value will use `[-x, x]` for dim0</span>
<span class="sd">                and nothing for the remaining dimensions.</span>
<span class="sd">            shear_range: shear_range with format matching `rotate_range`.</span>
<span class="sd">            translate_range: translate_range with format matching `rotate_range`.</span>
<span class="sd">            scale_range: scaling_range with format matching `rotate_range`. A value of 1.0 is added to the result.</span>
<span class="sd">                This allows 0 to correspond to no change (i.e., a scaling of 1).</span>
<span class="sd">            spatial_size: specifying output image spatial size [h, w, d].</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">                if the components of the `spatial_size` are non-positive values, the transform will use the</span>
<span class="sd">                corresponding components of img size. For example, `spatial_size=(32, 32, -1)` will be adapted</span>
<span class="sd">                to `(32, 32, 64)` if the third spatial dimension size of img is `64`.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``&quot;bilinear&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``&quot;reflection&quot;``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            as_tensor_output: the computation is implemented using pytorch tensors, this option specifies</span>
<span class="sd">                whether to convert it back to numpy arrays.</span>
<span class="sd">            device: device on which the tensor will be allocated.</span>

<span class="sd">        See also:</span>
<span class="sd">            - :py:class:`RandAffineGrid` for the random affine parameters configurations.</span>
<span class="sd">            - :py:class:`Affine` for the affine transformation parameters configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span> <span class="o">=</span> <span class="n">RandAffineGrid</span><span class="p">(</span><span class="n">rotate_range</span><span class="p">,</span> <span class="n">shear_range</span><span class="p">,</span> <span class="n">translate_range</span><span class="p">,</span> <span class="n">scale_range</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span> <span class="o">=</span> <span class="n">Resample</span><span class="p">(</span><span class="n">as_tensor_output</span><span class="o">=</span><span class="n">as_tensor_output</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_range</span> <span class="o">=</span> <span class="n">sigma_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_range</span> <span class="o">=</span> <span class="n">magnitude_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span> <span class="o">=</span> <span class="n">spatial_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="n">GridSampleMode</span> <span class="o">=</span> <span class="n">GridSampleMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">:</span> <span class="n">GridSamplePadMode</span> <span class="o">=</span> <span class="n">GridSamplePadMode</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rand_offset</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="Rand3DElastic.set_random_state"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElastic.set_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_random_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Rand3DElastic&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Rand3DElastic.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElastic.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rand_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">grid_size</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitude_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span></div>

<div class="viewcode-block" id="Rand3DElastic.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.Rand3DElastic.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSampleMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">padding_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">GridSamplePadMode</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: shape must be (num_channels, H, W, D),</span>
<span class="sd">            spatial_size: specifying spatial 3D output image spatial size [h, w, d].</span>
<span class="sd">                if `spatial_size` and `self.spatial_size` are not defined, or smaller than 1,</span>
<span class="sd">                the transform will use the spatial size of `img`.</span>
<span class="sd">            mode: {``&quot;bilinear&quot;``, ``&quot;nearest&quot;``}</span>
<span class="sd">                Interpolation mode to calculate output values. Defaults to ``self.mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">            padding_mode: {``&quot;zeros&quot;``, ``&quot;border&quot;``, ``&quot;reflection&quot;``}</span>
<span class="sd">                Padding mode for outside grid values. Defaults to ``self.padding_mode``.</span>
<span class="sd">                See also: https://pytorch.org/docs/stable/nn.functional.html#grid-sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">spatial_size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">grid_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">spatial_size</span><span class="o">=</span><span class="n">sp_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">gaussian</span> <span class="o">=</span> <span class="n">GaussianFilter</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rand_offset</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">offset</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_affine_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="n">padding_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_mode</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AddCoordinateChannels"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AddCoordinateChannels">[docs]</a><span class="k">class</span> <span class="nc">AddCoordinateChannels</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Appends additional channels encoding coordinates of the input. Useful when e.g. training using patch-based sampling,</span>
<span class="sd">    to allow feeding of the patch&#39;s location into the network.</span>

<span class="sd">    This can be seen as a input-only version of CoordConv:</span>

<span class="sd">    Liu, R. et al. An Intriguing Failing of Convolutional Neural Networks and the CoordConv Solution, NeurIPS 2018.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AddCoordinateChannels.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AddCoordinateChannels.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spatial_channels</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spatial_channels: the spatial dimensions that are to have their coordinates encoded in a channel and</span>
<span class="sd">                appended to the input. E.g., `(1,2,3)` will append three channels to the input, encoding the</span>
<span class="sd">                coordinates of the input&#39;s three spatial dimensions (0 is reserved for the channel dimension).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_channels</span> <span class="o">=</span> <span class="n">spatial_channels</span></div>

<div class="viewcode-block" id="AddCoordinateChannels.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AddCoordinateChannels.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: data to be transformed, assuming `img` is channel first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_channels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;input has </span><span class="si">{</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2"> spatial dimensions, cannot add AddCoordinateChannels channel for &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;dim </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_channels</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_channels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot add AddCoordinateChannels channel for dimension 0, as 0 is channel dim.&quot;</span><span class="p">)</span>

        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">coord_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spatial_dims</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">))</span>
        <span class="c1"># only keep required dimensions. need to subtract 1 since im will be 0-based</span>
        <span class="c1"># but user input is 1-based (because channel dim is 0)</span>
        <span class="n">coord_channels</span> <span class="o">=</span> <span class="n">coord_channels</span><span class="p">[[</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_channels</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">img</span><span class="p">,</span> <span class="n">coord_channels</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2021 MONAI Consortium.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>