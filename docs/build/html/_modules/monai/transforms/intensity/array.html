
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>monai.transforms.intensity.array &#8212; MONAI 0.6.0 Documentation</title>
    
  <link href="../../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/MONAI-logo-color.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../whatsnew.html">
  What’s New
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../highlights.html">
  Modules Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../installation.html">
  Installation Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../contrib.html">
  Development
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/Project-MONAI/tutorials">Tutorials<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/project-monai/monai" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/projectmonai" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for monai.transforms.intensity.array</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020 - 2021 MONAI Consortium</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A collection of &quot;vanilla&quot; transforms for intensity adjustment</span>
<span class="sd">https://github.com/Project-MONAI/MONAI/wiki/MONAI_Design</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">monai.config</span> <span class="kn">import</span> <span class="n">DtypeLike</span>
<span class="kn">from</span> <span class="nn">monai.networks.layers</span> <span class="kn">import</span> <span class="n">GaussianFilter</span><span class="p">,</span> <span class="n">HilbertTransform</span><span class="p">,</span> <span class="n">SavitzkyGolayFilter</span>
<span class="kn">from</span> <span class="nn">monai.transforms.transform</span> <span class="kn">import</span> <span class="n">RandomizableTransform</span><span class="p">,</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">monai.transforms.utils</span> <span class="kn">import</span> <span class="n">rescale_array</span>
<span class="kn">from</span> <span class="nn">monai.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PT_BEFORE_1_7</span><span class="p">,</span>
    <span class="n">InvalidPyTorchVersionError</span><span class="p">,</span>
    <span class="n">dtype_torch_to_numpy</span><span class="p">,</span>
    <span class="n">ensure_tuple</span><span class="p">,</span>
    <span class="n">ensure_tuple_rep</span><span class="p">,</span>
    <span class="n">ensure_tuple_size</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;RandGaussianNoise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandRicianNoise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ShiftIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandShiftIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StdShiftIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandStdShiftIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandBiasField&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ScaleIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandScaleIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NormalizeIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ThresholdIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ScaleIntensityRange&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AdjustContrast&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandAdjustContrast&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ScaleIntensityRangePercentiles&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MaskIntensity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DetectEnvelope&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SavitzkyGolaySmooth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GaussianSmooth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandGaussianSmooth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GaussianSharpen&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandGaussianSharpen&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandHistogramShift&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GibbsNoise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandGibbsNoise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;KSpaceSpikeNoise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RandKSpaceSpikeNoise&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="RandGaussianNoise"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianNoise">[docs]</a><span class="k">class</span> <span class="nc">RandGaussianNoise</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add Gaussian noise to image.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob: Probability to add Gaussian noise.</span>
<span class="sd">        mean: Mean or “centre” of the distribution.</span>
<span class="sd">        std: Standard deviation (spread) of distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">mean</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

<div class="viewcode-block" id="RandGaussianNoise.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianNoise.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">im_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandGaussianNoise.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianNoise.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype_torch_to_numpy</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">img</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">RandRicianNoise</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add Rician noise to image.</span>
<span class="sd">    Rician noise in MRI is the result of performing a magnitude operation on complex</span>
<span class="sd">    data with Gaussian noise of the same variance in both channels, as described in `Noise in Magnitude Magnetic Resonance Images</span>
<span class="sd">    &lt;https://doi.org/10.1002/cmr.a.20124&gt;`_. This transform is adapted from</span>
<span class="sd">    `DIPY&lt;https://github.com/dipy/dipy&gt;`_. See also: `The rician distribution of noisy mri data</span>
<span class="sd">    &lt;https://doi.org/10.1002/mrm.1910340618&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob: Probability to add Rician noise.</span>
<span class="sd">        mean: Mean or &quot;centre&quot; of the Gaussian distributions sampled to make up</span>
<span class="sd">            the Rician noise.</span>
<span class="sd">        std: Standard deviation (spread) of the Gaussian distributions sampled</span>
<span class="sd">            to make up the Rician noise.</span>
<span class="sd">        channel_wise: If True, treats each channel of the image separately.</span>
<span class="sd">        relative: If True, the spread of the sampled Gaussian distributions will</span>
<span class="sd">            be std times the standard deviation of the image or channel&#39;s intensity</span>
<span class="sd">            histogram.</span>
<span class="sd">        sample_std: If True, sample the spread of the Gaussian distributions</span>
<span class="sd">            uniformly from 0 to std.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">mean</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">std</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">channel_wise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">relative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sample_std</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span> <span class="o">=</span> <span class="n">channel_wise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative</span> <span class="o">=</span> <span class="n">relative</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_std</span> <span class="o">=</span> <span class="n">sample_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

    <span class="k">def</span> <span class="nf">_add_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">mean</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">std</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">im_shape</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_std</span> <span class="k">else</span> <span class="n">std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">_std</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">im_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">_std</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">im_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype_torch_to_numpy</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">img</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span><span class="p">:</span>
            <span class="n">_mean</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
            <span class="n">_std</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">_mean</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">=</span><span class="n">_std</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative</span> <span class="k">else</span> <span class="n">_std</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;If channel_wise is False, mean must be a float or int number.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;If channel_wise is False, std must be a float or int number.&quot;</span><span class="p">)</span>
            <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span>


<div class="viewcode-block" id="ShiftIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ShiftIntensity">[docs]</a><span class="k">class</span> <span class="nc">ShiftIntensity</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift intensity uniformly for the entire image with specified `offset`.</span>

<span class="sd">    Args:</span>
<span class="sd">        offset: offset value to shift the intensity of image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>

<div class="viewcode-block" id="ShiftIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ShiftIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">img</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandShiftIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandShiftIntensity">[docs]</a><span class="k">class</span> <span class="nc">RandShiftIntensity</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly shift intensity with randomly picked offset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandShiftIntensity.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandShiftIntensity.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offsets</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            offsets: offset range to randomly shift.</span>
<span class="sd">                if single number, offset value is picked from (-offsets, offsets).</span>
<span class="sd">            prob: probability of shift.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">offsets</span><span class="p">,</span> <span class="n">offsets</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">offsets</span><span class="p">,</span> <span class="n">offsets</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;offsets should be a number or pair of numbers.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">offsets</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">offsets</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandShiftIntensity.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandShiftIntensity.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandShiftIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandShiftIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">shifter</span> <span class="o">=</span> <span class="n">ShiftIntensity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shifter</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StdShiftIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.StdShiftIntensity">[docs]</a><span class="k">class</span> <span class="nc">StdShiftIntensity</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift intensity for the image with a factor and the standard deviation of the image</span>
<span class="sd">    by: ``v = v + factor * std(v)``.</span>
<span class="sd">    This transform can focus on only non-zero values or the entire image,</span>
<span class="sd">    and can also calculate the std on each channel separately.</span>

<span class="sd">    Args:</span>
<span class="sd">        factor: factor shift by ``v = v + factor * std(v)``.</span>
<span class="sd">        nonzero: whether only count non-zero values.</span>
<span class="sd">        channel_wise: if True, calculate on each channel separately. Please ensure</span>
<span class="sd">            that the first dimension represents the channel of the image if True.</span>
<span class="sd">        dtype: output data type, defaults to float32.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">nonzero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">channel_wise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span> <span class="o">=</span> <span class="n">nonzero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span> <span class="o">=</span> <span class="n">channel_wise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_stdshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">slices</span><span class="p">])</span>
        <span class="n">img</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">return</span> <span class="n">img</span>

<div class="viewcode-block" id="StdShiftIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.StdShiftIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stdshift</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stdshift</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span></div></div>


<div class="viewcode-block" id="RandStdShiftIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandStdShiftIntensity">[docs]</a><span class="k">class</span> <span class="nc">RandStdShiftIntensity</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift intensity for the image with a factor and the standard deviation of the image</span>
<span class="sd">    by: ``v = v + factor * std(v)`` where the `factor` is randomly picked.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandStdShiftIntensity.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandStdShiftIntensity.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">factors</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">nonzero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">channel_wise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            factors: if tuple, the randomly picked range is (min(factors), max(factors)).</span>
<span class="sd">                If single number, the range is (-factors, factors).</span>
<span class="sd">            prob: probability of std shift.</span>
<span class="sd">            nonzero: whether only count non-zero values.</span>
<span class="sd">            channel_wise: if True, calculate on each channel separately.</span>
<span class="sd">            dtype: output data type, defaults to float32.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">factors</span><span class="p">,</span> <span class="n">factors</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">factors</span><span class="p">,</span> <span class="n">factors</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;factors should be a number or pair of numbers.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">factors</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">factors</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span> <span class="o">=</span> <span class="n">nonzero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span> <span class="o">=</span> <span class="n">channel_wise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span></div>

<div class="viewcode-block" id="RandStdShiftIntensity.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandStdShiftIntensity.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandStdShiftIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandStdShiftIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">shifter</span> <span class="o">=</span> <span class="n">StdShiftIntensity</span><span class="p">(</span>
            <span class="n">factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span><span class="p">,</span> <span class="n">channel_wise</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">shifter</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ScaleIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ScaleIntensity">[docs]</a><span class="k">class</span> <span class="nc">ScaleIntensity</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale the intensity of input image to the given value range (minv, maxv).</span>
<span class="sd">    If `minv` and `maxv` not provided, use `factor` to scale image by ``v = v * (1 + factor)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ScaleIntensity.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ScaleIntensity.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">minv</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">maxv</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            minv: minimum value of output data.</span>
<span class="sd">            maxv: maximum value of output data.</span>
<span class="sd">            factor: factor scale by ``v = v * (1 + factor)``. In order to use</span>
<span class="sd">                this parameter, please set `minv` and `maxv` into None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minv</span> <span class="o">=</span> <span class="n">minv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxv</span> <span class="o">=</span> <span class="n">maxv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span></div>

<div class="viewcode-block" id="ScaleIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ScaleIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When ``self.minv=None`` or ``self.maxv=None`` and ``self.factor=None``. Incompatible values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rescale_array</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxv</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible values: minv=None or maxv=None and factor=None.&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandScaleIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandScaleIntensity">[docs]</a><span class="k">class</span> <span class="nc">RandScaleIntensity</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly scale the intensity of input image by ``v = v * (1 + factor)`` where the `factor`</span>
<span class="sd">    is randomly picked.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandScaleIntensity.__init__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandScaleIntensity.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            factors: factor range to randomly scale by ``v = v * (1 + factor)``.</span>
<span class="sd">                if single number, factor value is picked from (-factors, factors).</span>
<span class="sd">            prob: probability of scale.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">factors</span><span class="p">,</span> <span class="n">factors</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">factors</span><span class="p">,</span> <span class="n">factors</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;factors should be a number or pair of numbers.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">factors</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">factors</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandScaleIntensity.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandScaleIntensity.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="RandScaleIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandScaleIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">ScaleIntensity</span><span class="p">(</span><span class="n">minv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scaler</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandBiasField"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandBiasField">[docs]</a><span class="k">class</span> <span class="nc">RandBiasField</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random bias field augmentation for MR images.</span>
<span class="sd">    The bias field is considered as a linear combination of smoothly varying basis (polynomial)</span>
<span class="sd">    functions, as described in `Automated Model-Based Tissue Classification of MR Images of the Brain</span>
<span class="sd">    &lt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=811270&gt;`_.</span>
<span class="sd">    This implementation adapted from `NiftyNet</span>
<span class="sd">    &lt;https://github.com/NifTK/NiftyNet&gt;`_.</span>
<span class="sd">    Referred to `Longitudinal segmentation of age-related white matter hyperintensities</span>
<span class="sd">    &lt;https://www.sciencedirect.com/science/article/pii/S1361841517300257?via%3Dihub&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        degree: degree of freedom of the polynomials. The value should be no less than 1.</span>
<span class="sd">            Defaults to 3.</span>
<span class="sd">        coeff_range: range of the random coefficients. Defaults to (0.0, 0.1).</span>
<span class="sd">        dtype: output data type, defaults to float32.</span>
<span class="sd">        prob: probability to do random bias field.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">coeff_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;degree should be no less than 1.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="n">degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_range</span> <span class="o">=</span> <span class="n">coeff_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_generate_random_field</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spatial_shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">degree</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">coeff</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        products of polynomials as bias field estimations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeff_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">spatial_shape</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">coeff_mat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggrid2d</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coeff_mat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">pts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">):</span>
                        <span class="n">pts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">np_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">coeff_mat</span><span class="p">[</span><span class="n">np_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np_pts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggrid3d</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">coeff_mat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only supoprts 2D or 3D fields&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">field</span>

<div class="viewcode-block" id="RandBiasField.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandBiasField.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>
        <span class="n">n_coeff</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff_range</span><span class="p">,</span> <span class="n">n_coeff</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="RandBiasField.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandBiasField.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">img</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_bias_fields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_generate_random_field</span><span class="p">(</span>
                    <span class="n">spatial_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">img</span> <span class="o">*</span> <span class="n">_bias_fields</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NormalizeIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.NormalizeIntensity">[docs]</a><span class="k">class</span> <span class="nc">NormalizeIntensity</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize input based on provided args, using calculated mean and std if not provided.</span>
<span class="sd">    This transform can normalize only non-zero values or entire image, and can also calculate</span>
<span class="sd">    mean and std on each channel separately.</span>
<span class="sd">    When `channel_wise` is True, the first dimension of `subtrahend` and `divisor` should</span>
<span class="sd">    be the number of image channels if they are not None.</span>

<span class="sd">    Args:</span>
<span class="sd">        subtrahend: the amount to subtract by (usually the mean).</span>
<span class="sd">        divisor: the amount to divide by (usually the standard deviation).</span>
<span class="sd">        nonzero: whether only normalize non-zero values.</span>
<span class="sd">        channel_wise: if using calculated mean and std, calculate on each channel separately</span>
<span class="sd">            or calculate on the entire image directly.</span>
<span class="sd">        dtype: output data type, defaults to float32.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subtrahend</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">divisor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nonzero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">channel_wise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtrahend</span> <span class="o">=</span> <span class="n">subtrahend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divisor</span> <span class="o">=</span> <span class="n">divisor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span> <span class="o">=</span> <span class="n">nonzero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span> <span class="o">=</span> <span class="n">channel_wise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">div</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">img</span>

        <span class="n">_sub</span> <span class="o">=</span> <span class="n">sub</span> <span class="k">if</span> <span class="n">sub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">slices</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_sub</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">_sub</span> <span class="o">=</span> <span class="n">_sub</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>

        <span class="n">_div</span> <span class="o">=</span> <span class="n">div</span> <span class="k">if</span> <span class="n">div</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">slices</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">_div</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_div</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">_div</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_div</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">_div</span> <span class="o">=</span> <span class="n">_div</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
            <span class="n">_div</span><span class="p">[</span><span class="n">_div</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">img</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">-</span> <span class="n">_sub</span><span class="p">)</span> <span class="o">/</span> <span class="n">_div</span>
        <span class="k">return</span> <span class="n">img</span>

<div class="viewcode-block" id="NormalizeIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.NormalizeIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`, assuming `img` is a channel-first array if `self.channel_wise` is True,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrahend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrahend</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;img has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels, but subtrahend has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrahend</span><span class="p">)</span><span class="si">}</span><span class="s2"> components.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisor</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;img has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels, but divisor has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisor</span><span class="p">)</span><span class="si">}</span><span class="s2"> components.&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="n">sub</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrahend</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrahend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">div</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">divisor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrahend</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ThresholdIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ThresholdIntensity">[docs]</a><span class="k">class</span> <span class="nc">ThresholdIntensity</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the intensity values of whole image to below threshold or above threshold.</span>
<span class="sd">    And fill the remaining parts of the image to the `cval` value.</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold: the threshold to filter intensity values.</span>
<span class="sd">        above: filter values above the threshold or below the threshold, default is True.</span>
<span class="sd">        cval: value to fill the remaining parts of the image, default is 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">above</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;threshold must be a float or int number.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">above</span> <span class="o">=</span> <span class="n">above</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span>

<div class="viewcode-block" id="ThresholdIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ThresholdIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">above</span> <span class="k">else</span> <span class="n">img</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="ScaleIntensityRange"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ScaleIntensityRange">[docs]</a><span class="k">class</span> <span class="nc">ScaleIntensityRange</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply specific intensity scaling to the whole numpy array.</span>
<span class="sd">    Scaling from [a_min, a_max] to [b_min, b_max] with clip option.</span>

<span class="sd">    Args:</span>
<span class="sd">        a_min: intensity original range min.</span>
<span class="sd">        a_max: intensity original range max.</span>
<span class="sd">        b_min: intensity target range min.</span>
<span class="sd">        b_max: intensity target range max.</span>
<span class="sd">        clip: whether to perform clip after scaling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">a_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">clip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_min</span> <span class="o">=</span> <span class="n">a_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_max</span> <span class="o">=</span> <span class="n">a_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span> <span class="o">=</span> <span class="n">b_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_max</span> <span class="o">=</span> <span class="n">b_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="n">clip</span>

<div class="viewcode-block" id="ScaleIntensityRange.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ScaleIntensityRange.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_min</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Divide by zero (a_min == a_max)&quot;</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">img</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span>

        <span class="n">img</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_min</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_max</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">img</span></div></div>


<div class="viewcode-block" id="AdjustContrast"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AdjustContrast">[docs]</a><span class="k">class</span> <span class="nc">AdjustContrast</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes image intensity by gamma. Each pixel/voxel intensity is updated as::</span>

<span class="sd">        x = ((x - min) / intensity_range) ^ gamma * intensity_range + min</span>

<span class="sd">    Args:</span>
<span class="sd">        gamma: gamma value to adjust the contrast as function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;gamma must be a float or int number.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

<div class="viewcode-block" id="AdjustContrast.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.AdjustContrast.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-7</span>
        <span class="n">img_min</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">img_range</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">img_min</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(((</span><span class="n">img</span> <span class="o">-</span> <span class="n">img_min</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">img_range</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">img_range</span> <span class="o">+</span> <span class="n">img_min</span></div></div>


<div class="viewcode-block" id="RandAdjustContrast"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAdjustContrast">[docs]</a><span class="k">class</span> <span class="nc">RandAdjustContrast</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly changes image intensity by gamma. Each pixel/voxel intensity is updated as::</span>

<span class="sd">        x = ((x - min) / intensity_range) ^ gamma * intensity_range + min</span>

<span class="sd">    Args:</span>
<span class="sd">        prob: Probability of adjustment.</span>
<span class="sd">        gamma: Range of gamma values.</span>
<span class="sd">            If single number, value is picked from (0.5, gamma), default is (0.5, 4.5).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">gamma</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;if gamma is single number, must greater than 0.5 and value is picked from (0.5, gamma)&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;gamma should be a number or pair of numbers.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_value</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="RandAdjustContrast.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAdjustContrast.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="RandAdjustContrast.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandAdjustContrast.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">adjuster</span> <span class="o">=</span> <span class="n">AdjustContrast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adjuster</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ScaleIntensityRangePercentiles"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ScaleIntensityRangePercentiles">[docs]</a><span class="k">class</span> <span class="nc">ScaleIntensityRangePercentiles</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply range scaling to a numpy array based on the intensity distribution of the input.</span>

<span class="sd">    By default this transform will scale from [lower_intensity_percentile, upper_intensity_percentile] to [b_min, b_max], where</span>
<span class="sd">    {lower,upper}_intensity_percentile are the intensity values at the corresponding percentiles of ``img``.</span>

<span class="sd">    The ``relative`` parameter can also be set to scale from [lower_intensity_percentile, upper_intensity_percentile] to the</span>
<span class="sd">    lower and upper percentiles of the output range [b_min, b_max]</span>

<span class="sd">    For example:</span>

<span class="sd">    .. code-block:: python</span>
<span class="sd">        :emphasize-lines: 11, 22</span>

<span class="sd">        image = np.array(</span>
<span class="sd">            [[[1, 2, 3, 4, 5],</span>
<span class="sd">              [1, 2, 3, 4, 5],</span>
<span class="sd">              [1, 2, 3, 4, 5],</span>
<span class="sd">              [1, 2, 3, 4, 5],</span>
<span class="sd">              [1, 2, 3, 4, 5],</span>
<span class="sd">              [1, 2, 3, 4, 5]]])</span>

<span class="sd">        # Scale from lower and upper image intensity percentiles</span>
<span class="sd">        # to output range [b_min, b_max]</span>
<span class="sd">        scaler = ScaleIntensityRangePercentiles(10, 90, 0, 200, False, False)</span>
<span class="sd">        print(scaler(image))</span>
<span class="sd">        [[[0., 50., 100., 150., 200.],</span>
<span class="sd">          [0., 50., 100., 150., 200.],</span>
<span class="sd">          [0., 50., 100., 150., 200.],</span>
<span class="sd">          [0., 50., 100., 150., 200.],</span>
<span class="sd">          [0., 50., 100., 150., 200.],</span>
<span class="sd">          [0., 50., 100., 150., 200.]]]</span>

<span class="sd">        # Scale from lower and upper image intensity percentiles</span>
<span class="sd">        # to lower and upper percentiles of the output range [b_min, b_max]</span>
<span class="sd">        rel_scaler = ScaleIntensityRangePercentiles(10, 90, 0, 200, False, True)</span>
<span class="sd">        print(rel_scaler(image))</span>
<span class="sd">        [[[20., 60., 100., 140., 180.],</span>
<span class="sd">          [20., 60., 100., 140., 180.],</span>
<span class="sd">          [20., 60., 100., 140., 180.],</span>
<span class="sd">          [20., 60., 100., 140., 180.],</span>
<span class="sd">          [20., 60., 100., 140., 180.],</span>
<span class="sd">          [20., 60., 100., 140., 180.]]]</span>


<span class="sd">    Args:</span>
<span class="sd">        lower: lower intensity percentile.</span>
<span class="sd">        upper: upper intensity percentile.</span>
<span class="sd">        b_min: intensity target range min.</span>
<span class="sd">        b_max: intensity target range max.</span>
<span class="sd">        clip: whether to perform clip after scaling.</span>
<span class="sd">        relative: whether to scale to the corresponding percentiles of [b_min, b_max].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">b_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">clip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">relative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">lower</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Percentiles must be in the range [0, 100]&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upper</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">upper</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Percentiles must be in the range [0, 100]&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span> <span class="o">=</span> <span class="n">b_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_max</span> <span class="o">=</span> <span class="n">b_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="n">clip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative</span> <span class="o">=</span> <span class="n">relative</span>

<div class="viewcode-block" id="ScaleIntensityRangePercentiles.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.ScaleIntensityRangePercentiles.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `img`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>
        <span class="n">a_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
        <span class="n">b_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span>
        <span class="n">b_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_max</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative</span><span class="p">:</span>
            <span class="n">b_min</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">b_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span>
            <span class="n">b_max</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">b_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span>

        <span class="n">scalar</span> <span class="o">=</span> <span class="n">ScaleIntensityRange</span><span class="p">(</span><span class="n">a_min</span><span class="o">=</span><span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="n">a_max</span><span class="p">,</span> <span class="n">b_min</span><span class="o">=</span><span class="n">b_min</span><span class="p">,</span> <span class="n">b_max</span><span class="o">=</span><span class="n">b_max</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_max</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">img</span></div></div>


<div class="viewcode-block" id="MaskIntensity"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.MaskIntensity">[docs]</a><span class="k">class</span> <span class="nc">MaskIntensity</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask the intensity values of input image with the specified mask data.</span>
<span class="sd">    Mask data must have the same spatial size as the input image, and all</span>
<span class="sd">    the intensity values of input image corresponding to `0` in the mask</span>
<span class="sd">    data will be set to `0`, others will keep the original value.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask_data: if `mask_data` is single channel, apply to every channel</span>
<span class="sd">            of input image. if multiple channels, the number of channels must</span>
<span class="sd">            match the input data. `mask_data` will be converted to `bool` values</span>
<span class="sd">            by `mask_data &gt; 0` before applying transform to input image.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_data</span> <span class="o">=</span> <span class="n">mask_data</span>

<div class="viewcode-block" id="MaskIntensity.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.MaskIntensity.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mask_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            mask_data: if mask data is single channel, apply to every channel</span>
<span class="sd">                of input image. if multiple channels, the channel number must</span>
<span class="sd">                match input data. mask_data will be converted to `bool` values</span>
<span class="sd">                by `mask_data &gt; 0` before applying transform to input image.</span>

<span class="sd">        Raises:</span>
<span class="sd">            - ValueError: When both ``mask_data`` and ``self.mask_data`` are None.</span>
<span class="sd">            - ValueError: When ``mask_data`` and ``img`` channels differ and ``mask_data`` is not single channel.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown mask_data.&quot;</span><span class="p">)</span>
        <span class="n">mask_data_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask_data_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_data</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">mask_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask_data_</span> <span class="o">=</span> <span class="n">mask_data</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">mask_data_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask_data_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask_data_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mask_data_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When mask_data is not single channel, mask_data channels must match img, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got img=</span><span class="si">{</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> mask_data=</span><span class="si">{</span><span class="n">mask_data_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span> <span class="n">mask_data_</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SavitzkyGolaySmooth"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.SavitzkyGolaySmooth">[docs]</a><span class="k">class</span> <span class="nc">SavitzkyGolaySmooth</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth the input data along the given axis using a Savitzky-Golay filter.</span>

<span class="sd">    Args:</span>
<span class="sd">        window_length: Length of the filter window, must be a positive odd integer.</span>
<span class="sd">        order: Order of the polynomial to fit to each window, must be less than ``window_length``.</span>
<span class="sd">        axis: Optional axis along which to apply the filter kernel. Default 1 (first spatial dimension).</span>
<span class="sd">        mode: Optional padding mode, passed to convolution class. ``&#39;zeros&#39;``, ``&#39;reflect&#39;``, ``&#39;replicate&#39;``</span>
<span class="sd">            or ``&#39;circular&#39;``. Default: ``&#39;zeros&#39;``. See ``torch.nn.Conv1d()`` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zeros&quot;</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis must be zero or positive.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">window_length</span> <span class="o">=</span> <span class="n">window_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

<div class="viewcode-block" id="SavitzkyGolaySmooth.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.SavitzkyGolaySmooth.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img: numpy.ndarray containing input data. Must be real and in shape [channels, spatial1, spatial2, ...].</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray containing smoothed result.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add one to transform axis because a batch axis will be added at dimension 0</span>
        <span class="n">savgol_filter</span> <span class="o">=</span> <span class="n">SavitzkyGolayFilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>
        <span class="c1"># convert to Tensor and add Batch axis expected by HilbertTransform</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="DetectEnvelope"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.DetectEnvelope">[docs]</a><span class="k">class</span> <span class="nc">DetectEnvelope</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the envelope of the input data along the requested axis using a Hilbert transform.</span>
<span class="sd">    Requires PyTorch 1.7.0+ and the PyTorch FFT module (which is not included in NVIDIA PyTorch Release 20.10).</span>

<span class="sd">    Args:</span>
<span class="sd">        axis: Axis along which to detect the envelope. Default 1, i.e. the first spatial dimension.</span>
<span class="sd">        N: FFT size. Default img.shape[axis]. Input will be zero-padded or truncated to this size along dimension</span>
<span class="sd">        ``axis``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">PT_BEFORE_1_7</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidPyTorchVersionError</span><span class="p">(</span><span class="s2">&quot;1.7.0&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis must be zero or positive.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

<div class="viewcode-block" id="DetectEnvelope.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.DetectEnvelope.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            img: numpy.ndarray containing input data. Must be real and in shape [channels, spatial1, spatial2, ...].</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray containing envelope of data in img along the specified axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add one to transform axis because a batch axis will be added at dimension 0</span>
        <span class="n">hilbert_transform</span> <span class="o">=</span> <span class="n">HilbertTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># convert to Tensor and add Batch axis expected by HilbertTransform</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">))</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hilbert_transform</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span></div></div>


<div class="viewcode-block" id="GaussianSmooth"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.GaussianSmooth">[docs]</a><span class="k">class</span> <span class="nc">GaussianSmooth</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply Gaussian smooth to the input data based on specified `sigma` parameter.</span>
<span class="sd">    A default value `sigma=1.0` is provided for reference.</span>

<span class="sd">    Args:</span>
<span class="sd">        sigma: if a list of values, must match the count of spatial dimensions of input data,</span>
<span class="sd">            and apply every value in the list to 1 spatial dimension. if only 1 value provided,</span>
<span class="sd">            use it for all spatial dimensions.</span>
<span class="sd">        approx: discrete Gaussian kernel type, available options are &quot;erf&quot;, &quot;sampled&quot;, and &quot;scalespace&quot;.</span>
<span class="sd">            see also :py:meth:`monai.networks.layers.GaussianFilter`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">approx</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;erf&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approx</span> <span class="o">=</span> <span class="n">approx</span>

<div class="viewcode-block" id="GaussianSmooth.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.GaussianSmooth.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">gaussian_filter</span> <span class="o">=</span> <span class="n">GaussianFilter</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">approx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">approx</span><span class="p">)</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="RandGaussianSmooth"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianSmooth">[docs]</a><span class="k">class</span> <span class="nc">RandGaussianSmooth</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply Gaussian smooth to the input data based on randomly selected `sigma` parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        sigma_x: randomly select sigma value for the first spatial dimension.</span>
<span class="sd">        sigma_y: randomly select sigma value for the second spatial dimension if have.</span>
<span class="sd">        sigma_z: randomly select sigma value for the third spatial dimension if have.</span>
<span class="sd">        prob: probability of Gaussian smooth.</span>
<span class="sd">        approx: discrete Gaussian kernel type, available options are &quot;erf&quot;, &quot;sampled&quot;, and &quot;scalespace&quot;.</span>
<span class="sd">            see also :py:meth:`monai.networks.layers.GaussianFilter`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma_x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span>
        <span class="n">sigma_y</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span>
        <span class="n">sigma_z</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">approx</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;erf&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">=</span> <span class="n">sigma_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">=</span> <span class="n">sigma_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_z</span> <span class="o">=</span> <span class="n">sigma_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approx</span> <span class="o">=</span> <span class="n">approx</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="RandGaussianSmooth.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianSmooth.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="RandGaussianSmooth.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianSmooth.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">ensure_tuple_size</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GaussianSmooth</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">approx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">approx</span><span class="p">)(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="GaussianSharpen"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.GaussianSharpen">[docs]</a><span class="k">class</span> <span class="nc">GaussianSharpen</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sharpen images using the Gaussian Blur filter.</span>
<span class="sd">    Referring to: http://scipy-lectures.org/advanced/image_processing/auto_examples/plot_sharpen.html.</span>
<span class="sd">    The algorithm is shown as below</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        blurred_f = gaussian_filter(img, sigma1)</span>
<span class="sd">        filter_blurred_f = gaussian_filter(blurred_f, sigma2)</span>
<span class="sd">        img = blurred_f + alpha * (blurred_f - filter_blurred_f)</span>

<span class="sd">    A set of default values `sigma1=3.0`, `sigma2=1.0` and `alpha=30.0` is provide for reference.</span>

<span class="sd">    Args:</span>
<span class="sd">        sigma1: sigma parameter for the first gaussian kernel. if a list of values, must match the count</span>
<span class="sd">            of spatial dimensions of input data, and apply every value in the list to 1 spatial dimension.</span>
<span class="sd">            if only 1 value provided, use it for all spatial dimensions.</span>
<span class="sd">        sigma2: sigma parameter for the second gaussian kernel. if a list of values, must match the count</span>
<span class="sd">            of spatial dimensions of input data, and apply every value in the list to 1 spatial dimension.</span>
<span class="sd">            if only 1 value provided, use it for all spatial dimensions.</span>
<span class="sd">        alpha: weight parameter to compute the final result.</span>
<span class="sd">        approx: discrete Gaussian kernel type, available options are &quot;erf&quot;, &quot;sampled&quot;, and &quot;scalespace&quot;.</span>
<span class="sd">            see also :py:meth:`monai.networks.layers.GaussianFilter`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">sigma2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">30.0</span><span class="p">,</span>
        <span class="n">approx</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;erf&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma1</span> <span class="o">=</span> <span class="n">sigma1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma2</span> <span class="o">=</span> <span class="n">sigma2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approx</span> <span class="o">=</span> <span class="n">approx</span>

<div class="viewcode-block" id="GaussianSharpen.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.GaussianSharpen.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">gaussian_filter1</span> <span class="o">=</span> <span class="n">GaussianFilter</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">approx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">approx</span><span class="p">)</span>
        <span class="n">gaussian_filter2</span> <span class="o">=</span> <span class="n">GaussianFilter</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma2</span><span class="p">,</span> <span class="n">approx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">approx</span><span class="p">)</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">blurred_f</span> <span class="o">=</span> <span class="n">gaussian_filter1</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
        <span class="n">filter_blurred_f</span> <span class="o">=</span> <span class="n">gaussian_filter2</span><span class="p">(</span><span class="n">blurred_f</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">blurred_f</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">blurred_f</span> <span class="o">-</span> <span class="n">filter_blurred_f</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="RandGaussianSharpen"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianSharpen">[docs]</a><span class="k">class</span> <span class="nc">RandGaussianSharpen</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sharpen images using the Gaussian Blur filter based on randomly selected `sigma1`, `sigma2` and `alpha`.</span>
<span class="sd">    The algorithm is :py:class:`monai.transforms.GaussianSharpen`.</span>

<span class="sd">    Args:</span>
<span class="sd">        sigma1_x: randomly select sigma value for the first spatial dimension of first gaussian kernel.</span>
<span class="sd">        sigma1_y: randomly select sigma value for the second spatial dimension(if have) of first gaussian kernel.</span>
<span class="sd">        sigma1_z: randomly select sigma value for the third spatial dimension(if have) of first gaussian kernel.</span>
<span class="sd">        sigma2_x: randomly select sigma value for the first spatial dimension of second gaussian kernel.</span>
<span class="sd">            if only 1 value `X` provided, it must be smaller than `sigma1_x` and randomly select from [X, sigma1_x].</span>
<span class="sd">        sigma2_y: randomly select sigma value for the second spatial dimension(if have) of second gaussian kernel.</span>
<span class="sd">            if only 1 value `Y` provided, it must be smaller than `sigma1_y` and randomly select from [Y, sigma1_y].</span>
<span class="sd">        sigma2_z: randomly select sigma value for the third spatial dimension(if have) of second gaussian kernel.</span>
<span class="sd">            if only 1 value `Z` provided, it must be smaller than `sigma1_z` and randomly select from [Z, sigma1_z].</span>
<span class="sd">        alpha: randomly select weight parameter to compute the final result.</span>
<span class="sd">        approx: discrete Gaussian kernel type, available options are &quot;erf&quot;, &quot;sampled&quot;, and &quot;scalespace&quot;.</span>
<span class="sd">            see also :py:meth:`monai.networks.layers.GaussianFilter`.</span>
<span class="sd">        prob: probability of Gaussian sharpen.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma1_x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">sigma1_y</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">sigma1_z</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">sigma2_x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">sigma2_y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">sigma2_z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">),</span>
        <span class="n">approx</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;erf&quot;</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma1_x</span> <span class="o">=</span> <span class="n">sigma1_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma1_y</span> <span class="o">=</span> <span class="n">sigma1_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma1_z</span> <span class="o">=</span> <span class="n">sigma1_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_x</span> <span class="o">=</span> <span class="n">sigma2_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_y</span> <span class="o">=</span> <span class="n">sigma2_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_z</span> <span class="o">=</span> <span class="n">sigma2_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approx</span> <span class="o">=</span> <span class="n">approx</span>

<div class="viewcode-block" id="RandGaussianSharpen.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianSharpen.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma1_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma1_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma1_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma1_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma1_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma1_z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sigma2_x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma2_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x1</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma2_x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_x</span>
        <span class="n">sigma2_y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma2_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y1</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma2_y</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_y</span>
        <span class="n">sigma2_z</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma2_z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z1</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma2_z</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">sigma2_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">sigma2_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">sigma2_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">sigma2_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">sigma2_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">sigma2_z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="RandGaussianSharpen.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGaussianSharpen.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">sigma1</span> <span class="o">=</span> <span class="n">ensure_tuple_size</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z1</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sigma2</span> <span class="o">=</span> <span class="n">ensure_tuple_size</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z2</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GaussianSharpen</span><span class="p">(</span><span class="n">sigma1</span><span class="o">=</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="o">=</span><span class="n">sigma2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">approx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">approx</span><span class="p">)(</span><span class="n">img</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RandHistogramShift"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandHistogramShift">[docs]</a><span class="k">class</span> <span class="nc">RandHistogramShift</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply random nonlinear transform to the image&#39;s intensity histogram.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_control_points: number of control points governing the nonlinear intensity mapping.</span>
<span class="sd">            a smaller number of control points allows for larger intensity shifts. if two values provided, number of</span>
<span class="sd">            control points selecting from range (min_value, max_value).</span>
<span class="sd">        prob: probability of histogram shift.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_control_points</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_control_points</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num_control_points</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;num_control_points should be greater than or equal to 3&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_control_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_control_points</span><span class="p">,</span> <span class="n">num_control_points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_control_points</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;num_control points should be a number or a pair of numbers&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_control_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;num_control_points should be greater than or equal to 3&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_control_points</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">num_control_points</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_control_points</span><span class="p">))</span>

<div class="viewcode-block" id="RandHistogramShift.randomize"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandHistogramShift.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">num_control_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_control_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_control_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_control_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_control_point</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">floating_control_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_control_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_control_point</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">floating_control_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">floating_control_points</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">floating_control_points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="RandHistogramShift.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandHistogramShift.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span>
        <span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">img</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">reference_control_points_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_control_points</span> <span class="o">*</span> <span class="p">(</span><span class="n">img_max</span> <span class="o">-</span> <span class="n">img_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">img_min</span>
        <span class="n">floating_control_points_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floating_control_points</span> <span class="o">*</span> <span class="p">(</span><span class="n">img_max</span> <span class="o">-</span> <span class="n">img_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">img_min</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">reference_control_points_scaled</span><span class="p">,</span> <span class="n">floating_control_points_scaled</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="RandGibbsNoise"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGibbsNoise">[docs]</a><span class="k">class</span> <span class="nc">RandGibbsNoise</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Naturalistic image augmentation via Gibbs artifacts. The transform</span>
<span class="sd">    randomly applies Gibbs noise to 2D/3D MRI images. Gibbs artifacts</span>
<span class="sd">    are one of the common type of type artifacts appearing in MRI scans.</span>

<span class="sd">    The transform is applied to all the channels in the data.</span>

<span class="sd">    For general information on Gibbs artifacts, please refer to:</span>
<span class="sd">    https://pubs.rsna.org/doi/full/10.1148/rg.313105115</span>
<span class="sd">    https://pubs.rsna.org/doi/full/10.1148/radiographics.22.4.g02jl14949</span>


<span class="sd">    Args:</span>
<span class="sd">        prob (float): probability of applying the transform.</span>
<span class="sd">        alpha (float, Sequence(float)): Parametrizes the intensity of the Gibbs noise filter applied. Takes</span>
<span class="sd">            values in the interval [0,1] with alpha = 0 acting as the identity mapping.</span>
<span class="sd">            If a length-2 list is given as [a,b] then the value of alpha will be</span>
<span class="sd">            sampled uniformly from the interval [a,b]. 0 &lt;= a &lt;= b &lt;= 1.</span>
<span class="sd">        as_tensor_output: if true return torch.Tensor, else return np.array. default: True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;alpha length must be 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;alpha must take values in the interval [0,1]&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;When alpha = [a,b] we need a &lt; b.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_alpha</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>  <span class="c1"># stores last alpha sampled by randomize()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>

        <span class="n">RandomizableTransform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">)</span>

<div class="viewcode-block" id="RandGibbsNoise.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandGibbsNoise.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>

        <span class="c1"># randomize application and possibly alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
            <span class="c1"># apply transform</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">GibbsNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampled_alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">img</span></div>

    <span class="k">def</span> <span class="nf">_randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (1) Set random variable to apply the transform.</span>
<span class="sd">        (2) Get alpha from uniform distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="GibbsNoise"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.GibbsNoise">[docs]</a><span class="k">class</span> <span class="nc">GibbsNoise</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The transform applies Gibbs noise to 2D/3D MRI images. Gibbs artifacts</span>
<span class="sd">    are one of the common type of type artifacts appearing in MRI scans.</span>

<span class="sd">    The transform is applied to all the channels in the data.</span>

<span class="sd">    For general information on Gibbs artifacts, please refer to:</span>
<span class="sd">    https://pubs.rsna.org/doi/full/10.1148/rg.313105115</span>
<span class="sd">    https://pubs.rsna.org/doi/full/10.1148/radiographics.22.4.g02jl14949</span>


<span class="sd">    Args:</span>
<span class="sd">        alpha (float): Parametrizes the intensity of the Gibbs noise filter applied. Takes</span>
<span class="sd">            values in the interval [0,1] with alpha = 0 acting as the identity mapping.</span>
<span class="sd">        as_tensor_output: if true return torch.Tensor, else return np.array. default: True.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;alpha must take values in the interval [0,1].&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GibbsNoise.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.GibbsNoise.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">n_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># convert to ndarray to work with np.fft</span>
        <span class="n">_device</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">_device</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">device</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="c1"># FT</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_fourier</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">)</span>
        <span class="c1"># build and apply mask</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_mask</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="c1"># map back</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_shift_fourier</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">_device</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="k">else</span> <span class="n">img</span></div>

    <span class="k">def</span> <span class="nf">_shift_fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">n_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies fourier transform and shifts its output.</span>
<span class="sd">        Only the spatial dimensions get transformed.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (np.ndarray): tensor to fourier transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_inv_shift_fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">n_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies inverse shift and fourier transform. Only the spatial</span>
<span class="sd">        dimensions are transformed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Builds and applies a mask on the spatial dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            k (np.ndarray): k-space version of the image.</span>
<span class="sd">        Returns:</span>
<span class="sd">            masked version of the k-space image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># compute masking radius and center</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># gives list w/ len==self.dim. Each dim gives coordinate in that dimension</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)]</span>

        <span class="c1"># need to subtract center coord and then square for Euc distance</span>
        <span class="n">coords_from_center_sq</span> <span class="o">=</span> <span class="p">[(</span><span class="n">coord</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">center</span><span class="p">)]</span>
        <span class="n">dist_from_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">coords_from_center_sq</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">dist_from_center</span> <span class="o">&lt;=</span> <span class="n">r</span>

        <span class="c1"># add channel dimension into mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># apply binary mask</span>
        <span class="n">k_masked</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">k_masked</span></div>


<div class="viewcode-block" id="KSpaceSpikeNoise"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.KSpaceSpikeNoise">[docs]</a><span class="k">class</span> <span class="nc">KSpaceSpikeNoise</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply localized spikes in `k`-space at the given locations and intensities.</span>
<span class="sd">    Spike (Herringbone) artifact is a type of data acquisition artifact which</span>
<span class="sd">    may occur during MRI scans.</span>

<span class="sd">    For general information on spike artifacts, please refer to:</span>

<span class="sd">    `AAPM/RSNA physics tutorial for residents: fundamental physics of MR imaging</span>
<span class="sd">    &lt;https://pubmed.ncbi.nlm.nih.gov/16009826&gt;`_.</span>

<span class="sd">    `Body MRI artifacts in clinical practice: A physicist&#39;s and radiologist&#39;s</span>
<span class="sd">    perspective &lt;https://doi.org/10.1002/jmri.24288&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        loc: spatial location for the spikes. For</span>
<span class="sd">            images with 3D spatial dimensions, the user can provide (C, X, Y, Z)</span>
<span class="sd">            to fix which channel C is affected, or (X, Y, Z) to place the same</span>
<span class="sd">            spike in all channels. For 2D cases, the user can provide (C, X, Y)</span>
<span class="sd">            or (X, Y).</span>
<span class="sd">        k_intensity: value for the log-intensity of the</span>
<span class="sd">            `k`-space version of the image. If one location is passed to ``loc`` or the</span>
<span class="sd">            channel is not specified, then this argument should receive a float. If</span>
<span class="sd">            ``loc`` is given a sequence of locations, then this argument should</span>
<span class="sd">            receive a sequence of intensities. This value should be tested as it is</span>
<span class="sd">            data-dependent. The default values are the 2.5 the mean of the</span>
<span class="sd">            log-intensity for each channel.</span>
<span class="sd">        as_tensor_output: if ``True`` return torch.Tensor, else return np.array.</span>
<span class="sd">            Default: ``True``.</span>

<span class="sd">    Example:</span>
<span class="sd">        When working with 4D data, ``KSpaceSpikeNoise(loc = ((3,60,64,32), (64,60,32)), k_intensity = (13,14))``</span>
<span class="sd">        will place a spike at `[3, 60, 64, 32]` with `log-intensity = 13`, and</span>
<span class="sd">        one spike per channel located respectively at `[: , 64, 60, 32]`</span>
<span class="sd">        with `log-intensity = 14`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]],</span>
        <span class="n">k_intensity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_intensity</span> <span class="o">=</span> <span class="n">k_intensity</span>

        <span class="c1"># assert one-to-one relationship between factors and locations</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_intensity</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;If a sequence is passed to k_intensity, then a sequence of locations must be passed to loc&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_intensity</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;There must be one intensity_factor value for each tuple of indices in loc.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k_intensity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_intensity</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;There must be one intensity_factor value for each tuple of indices in loc.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="KSpaceSpikeNoise.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.KSpaceSpikeNoise.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            img (np.array or torch.tensor): image with dimensions (C, H, W) or (C, H, W, D)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># checking that tuples in loc are consistent with img size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_indices</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Image needs a channel direction.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Input images of dimension 4 need location tuple to be length 3 or 4&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Input images of dimension 4 need location tuple to be length 3 or 4&quot;</span><span class="p">)</span>

        <span class="n">n_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># convert to ndarray to work with np.fft</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">device</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

        <span class="c1"># FT</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_fourier</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">)</span>
        <span class="n">log_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="n">k_intensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_intensity</span>
        <span class="c1"># default log intensity</span>
        <span class="k">if</span> <span class="n">k_intensity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k_intensity</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_abs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">2.5</span><span class="p">)</span>

        <span class="c1"># highlight</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">k_intensity</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_spike</span><span class="p">(</span><span class="n">log_abs</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_spike</span><span class="p">(</span><span class="n">log_abs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">k_intensity</span><span class="p">)</span>
        <span class="c1"># map back</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_abs</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_shift_fourier</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="k">else</span> <span class="n">img</span></div>

    <span class="k">def</span> <span class="nf">_check_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Helper method to check consistency of self.loc and input image.</span>

<span class="sd">        Raises assertion error if any index in loc is out of bounds.&quot;&quot;&quot;</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The index value at position </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> of one of the tuples in loc = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="si">}</span><span class="s2"> is out of bounds for current image.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_spike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to introduce a given intensity at given location.</span>

<span class="sd">        Args:</span>
<span class="sd">            k (np.array): intensity array to alter.</span>
<span class="sd">            idx (tuple): index of location where to apply change.</span>
<span class="sd">            val (float): value of intensity to write in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">k</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">k</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">_shift_fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">n_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies fourier transform and shifts its output.</span>
<span class="sd">        Only the spatial dimensions get transformed.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (np.ndarray): tensor to fourier transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_inv_shift_fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">n_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies inverse shift and fourier transform. Only the spatial</span>
<span class="sd">        dimensions are transformed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="RandKSpaceSpikeNoise"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandKSpaceSpikeNoise">[docs]</a><span class="k">class</span> <span class="nc">RandKSpaceSpikeNoise</span><span class="p">(</span><span class="n">RandomizableTransform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Naturalistic data augmentation via spike artifacts. The transform applies</span>
<span class="sd">    localized spikes in `k`-space, and it is the random version of</span>
<span class="sd">    :py:class:`monai.transforms.KSpaceSpikeNoise`.</span>

<span class="sd">    Spike (Herringbone) artifact is a type of data acquisition artifact which</span>
<span class="sd">    may occur during MRI scans. For general information on spike artifacts,</span>
<span class="sd">    please refer to:</span>

<span class="sd">    `AAPM/RSNA physics tutorial for residents: fundamental physics of MR imaging</span>
<span class="sd">    &lt;https://pubmed.ncbi.nlm.nih.gov/16009826&gt;`_.</span>

<span class="sd">    `Body MRI artifacts in clinical practice: A physicist&#39;s and radiologist&#39;s</span>
<span class="sd">    perspective &lt;https://doi.org/10.1002/jmri.24288&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob: probability of applying the transform, either on all</span>
<span class="sd">            channels at once, or channel-wise if ``channel_wise = True``.</span>
<span class="sd">        intensity_range: pass a tuple</span>
<span class="sd">            (a, b) to sample the log-intensity from the interval (a, b)</span>
<span class="sd">            uniformly for all channels. Or pass sequence of intevals</span>
<span class="sd">            ((a0, b0), (a1, b1), ...) to sample for each respective channel.</span>
<span class="sd">            In the second case, the number of 2-tuples must match the number of</span>
<span class="sd">            channels.</span>
<span class="sd">            Default ranges is `(0.95x, 1.10x)` where `x` is the mean</span>
<span class="sd">            log-intensity for each channel.</span>
<span class="sd">        channel_wise: treat each channel independently. True by</span>
<span class="sd">            default.</span>
<span class="sd">        as_tensor_output: if True return torch.Tensor, else</span>
<span class="sd">            return np.array. default: True.</span>

<span class="sd">    Example:</span>
<span class="sd">        To apply `k`-space spikes randomly with probability 0.5, and</span>
<span class="sd">        log-intensity sampled from the interval [11, 12] for each channel</span>
<span class="sd">        independently, one uses</span>
<span class="sd">        ``RandKSpaceSpikeNoise(prob=0.5, intensity_range=(11, 12), channel_wise=True)``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">intensity_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channel_wise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">as_tensor_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span> <span class="o">=</span> <span class="n">intensity_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span> <span class="o">=</span> <span class="n">channel_wise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="o">=</span> <span class="n">as_tensor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_k_intensity</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_locs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">intensity_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">channel_wise</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;When channel_wise = False, intensity_range should be a 2-tuple (low, high) or None.&quot;</span>
                <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>

<div class="viewcode-block" id="RandKSpaceSpikeNoise.__call__"><a class="viewcode-back" href="../../../../transforms.html#monai.transforms.RandKSpaceSpikeNoise.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply transform to `img`. Assumes data is in channel-first form.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (np.array or torch.tensor): image with dimensions (C, H, W) or (C, H, W, D)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">)</span> <span class="o">!=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;If intensity_range is a sequence of sequences, then there must be one (low, high) tuple for each channel.&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_k_intensity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_locs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># convert to ndarray to work with np.fft</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_numpy</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">intensity_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_sequence</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_randomize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">intensity_range</span><span class="p">)</span>

        <span class="c1"># build/appy transform only if there are spike locations</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled_locs</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">KSpaceSpikeNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampled_locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled_k_intensity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_tensor_output</span> <span class="k">else</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">_randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">intensity_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to sample both the location and intensity of the spikes.</span>
<span class="sd">        When not working channel wise (channel_wise=False) it use the random</span>
<span class="sd">        variable ``self._do_transform`` to decide whether to sample a location</span>
<span class="sd">        and intensity.</span>

<span class="sd">        When working channel wise, the method randomly samples a location and</span>
<span class="sd">        intensity for each channel depending on ``self._do_transform``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># randomizing per channel</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wise</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sampled_locs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">chan</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sampled_k_intensity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intensity_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># working with all channels together</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_transform</span><span class="p">:</span>
                <span class="n">spatial</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampled_locs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="n">spatial</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sampled_k_intensity</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">intensity_range</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sampled_k_intensity</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">_make_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formats the sequence of intensities ranges to Sequence[Sequence[float]].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">intensity_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">ensure_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">),)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">intensity_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set default range if one not provided</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_default_range</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_default_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets default intensity ranges to be sampled.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (np.ndarray): tensor to fourier transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">log_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
        <span class="n">shifted_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_abs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">2.5</span>
        <span class="n">intensity_sequence</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">i</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shifted_means</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">intensity_sequence</span>

    <span class="k">def</span> <span class="nf">_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">img</span><span class="o">.</span><span class="n">device</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2021 MONAI Consortium.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>