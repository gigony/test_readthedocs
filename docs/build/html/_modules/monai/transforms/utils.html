
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>monai.transforms.utils &#8212; MONAI 0.6.0 Documentation</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/MONAI-logo-color.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../whatsnew.html">
  Whatâ€™s New
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../highlights.html">
  Modules Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../installation.html">
  Installation Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../contrib.html">
  Development
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/Project-MONAI/tutorials">Tutorials<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/project-monai/monai" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/projectmonai" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for monai.transforms.utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020 - 2021 MONAI Consortium</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">monai.config</span> <span class="kn">import</span> <span class="n">DtypeLike</span><span class="p">,</span> <span class="n">IndexSelection</span>
<span class="kn">from</span> <span class="nn">monai.networks.layers</span> <span class="kn">import</span> <span class="n">GaussianFilter</span>
<span class="kn">from</span> <span class="nn">monai.transforms.compose</span> <span class="kn">import</span> <span class="n">Compose</span>
<span class="kn">from</span> <span class="nn">monai.transforms.transform</span> <span class="kn">import</span> <span class="n">MapTransform</span>
<span class="kn">from</span> <span class="nn">monai.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GridSampleMode</span><span class="p">,</span>
    <span class="n">InterpolateMode</span><span class="p">,</span>
    <span class="n">InverseKeys</span><span class="p">,</span>
    <span class="n">ensure_tuple</span><span class="p">,</span>
    <span class="n">ensure_tuple_rep</span><span class="p">,</span>
    <span class="n">ensure_tuple_size</span><span class="p">,</span>
    <span class="n">fall_back_tuple</span><span class="p">,</span>
    <span class="n">issequenceiterable</span><span class="p">,</span>
    <span class="n">min_version</span><span class="p">,</span>
    <span class="n">optional_import</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">measure</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;skimage.measure&quot;</span><span class="p">,</span> <span class="s2">&quot;0.14.2&quot;</span><span class="p">,</span> <span class="n">min_version</span><span class="p">)</span>
<span class="n">cp</span><span class="p">,</span> <span class="n">has_cp</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;cupy&quot;</span><span class="p">)</span>
<span class="n">cp_ndarray</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;cupy&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ndarray&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;rand_choice&quot;</span><span class="p">,</span>
    <span class="s2">&quot;img_bounds&quot;</span><span class="p">,</span>
    <span class="s2">&quot;in_bounds&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_empty&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_positive&quot;</span><span class="p">,</span>
    <span class="s2">&quot;zero_margins&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rescale_array&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rescale_instance_array&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rescale_array_int_max&quot;</span><span class="p">,</span>
    <span class="s2">&quot;copypaste_arrays&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compute_divisible_spatial_size&quot;</span><span class="p">,</span>
    <span class="s2">&quot;resize_center&quot;</span><span class="p">,</span>
    <span class="s2">&quot;map_binary_to_indices&quot;</span><span class="p">,</span>
    <span class="s2">&quot;weighted_patch_samples&quot;</span><span class="p">,</span>
    <span class="s2">&quot;generate_pos_neg_label_crop_centers&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_grid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_control_grid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_rotate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_shear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_scale&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_translate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;generate_spatial_bounding_box&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_largest_connected_component_mask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_extreme_points&quot;</span><span class="p">,</span>
    <span class="s2">&quot;extreme_points_to_image&quot;</span><span class="p">,</span>
    <span class="s2">&quot;map_spatial_axes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;allow_missing_keys_mode&quot;</span><span class="p">,</span>
    <span class="s2">&quot;convert_inverse_interp_mode&quot;</span><span class="p">,</span>
    <span class="s2">&quot;convert_to_tensor&quot;</span><span class="p">,</span>
    <span class="s2">&quot;convert_to_numpy&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tensor_to_numpy&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="rand_choice"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.rand_choice">[docs]</a><span class="k">def</span> <span class="nf">rand_choice</span><span class="p">(</span><span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if a randomly chosen number is less than or equal to `prob`, by default this is a 50/50 chance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="img_bounds"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.img_bounds">[docs]</a><span class="k">def</span> <span class="nf">img_bounds</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the minimum and maximum indices of non-zero lines in axis 0 of `img`, followed by that for axis 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ax0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ax0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ax1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]))</span></div>


<div class="viewcode-block" id="in_bounds"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.in_bounds">[docs]</a><span class="k">def</span> <span class="nf">in_bounds</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxx</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxy</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if (x,y) is within the rectangle (margin, margin, maxx-margin, maxy-margin).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span> <span class="ow">and</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">margin</span><span class="p">))</span></div>


<div class="viewcode-block" id="is_empty"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.is_empty">[docs]</a><span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if `img` is empty, that is its maximum value is not greater than its minimum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>  <span class="c1"># use &gt; instead of &lt;= so that an image full of NaNs will result in True</span></div>


<div class="viewcode-block" id="is_positive"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.is_positive">[docs]</a><span class="k">def</span> <span class="nf">is_positive</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a boolean version of `img` where the positive values are converted into True, the other values are False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="zero_margins"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.zero_margins">[docs]</a><span class="k">def</span> <span class="nf">zero_margins</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the values within `margin` indices of the edges of `img` in dimensions 1 and 2 are 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">margin</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">margin</span><span class="p">:]):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:</span><span class="n">margin</span><span class="p">,</span> <span class="p">:])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="o">-</span><span class="n">margin</span><span class="p">:,</span> <span class="p">:])</span></div>


<div class="viewcode-block" id="rescale_array"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.rescale_array">[docs]</a><span class="k">def</span> <span class="nf">rescale_array</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">minv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">maxv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescale the values of numpy array `arr` to be from `minv` to `maxv`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">mina</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">maxa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mina</span> <span class="o">==</span> <span class="n">maxa</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span> <span class="o">*</span> <span class="n">minv</span>

    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">mina</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">maxa</span> <span class="o">-</span> <span class="n">mina</span><span class="p">)</span>  <span class="c1"># normalize the array first</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxv</span> <span class="o">-</span> <span class="n">minv</span><span class="p">))</span> <span class="o">+</span> <span class="n">minv</span>  <span class="c1"># rescale by minv and maxv, which is the normalized array by default</span></div>


<div class="viewcode-block" id="rescale_instance_array"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.rescale_instance_array">[docs]</a><span class="k">def</span> <span class="nf">rescale_instance_array</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">minv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">maxv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescale each array slice along the first dimension of `arr` independently.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rescale_array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">minv</span><span class="p">,</span> <span class="n">maxv</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="rescale_array_int_max"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.rescale_array_int_max">[docs]</a><span class="k">def</span> <span class="nf">rescale_array_int_max</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescale the array `arr` to be between the minimum and maximum values of the type `dtype`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rescale_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">max</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="copypaste_arrays"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.copypaste_arrays">[docs]</a><span class="k">def</span> <span class="nf">copypaste_arrays</span><span class="p">(</span>
    <span class="n">src_shape</span><span class="p">,</span>
    <span class="n">dest_shape</span><span class="p">,</span>
    <span class="n">srccenter</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">destcenter</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the slices to copy a sliced area of array in `src_shape` into array in `dest_shape`.</span>

<span class="sd">    The area has dimensions `dims` (use 0 or None to copy everything in that dimension),</span>
<span class="sd">    the source area is centered at `srccenter` index in `src` and copied into area centered at `destcenter` in `dest`.</span>
<span class="sd">    The dimensions of the copied area will be clipped to fit within the</span>
<span class="sd">    source and destination arrays so a smaller area may be copied than expected. Return value is the tuples of slice</span>
<span class="sd">    objects indexing the copied area in `src`, and those indexing the copy area in `dest`.</span>

<span class="sd">    Example</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        src_shape = (6,6)</span>
<span class="sd">        src = np.random.randint(0,10,src_shape)</span>
<span class="sd">        dest = np.zeros_like(src)</span>
<span class="sd">        srcslices, destslices = copypaste_arrays(src_shape, dest.shape, (3, 2),(2, 1),(3, 4))</span>
<span class="sd">        dest[destslices] = src[srcslices]</span>
<span class="sd">        print(src)</span>
<span class="sd">        print(dest)</span>

<span class="sd">        &gt;&gt;&gt; [[9 5 6 6 9 6]</span>
<span class="sd">             [4 3 5 6 1 2]</span>
<span class="sd">             [0 7 3 2 4 1]</span>
<span class="sd">             [3 0 0 1 5 1]</span>
<span class="sd">             [9 4 7 1 8 2]</span>
<span class="sd">             [6 6 5 8 6 7]]</span>
<span class="sd">            [[0 0 0 0 0 0]</span>
<span class="sd">             [7 3 2 4 0 0]</span>
<span class="sd">             [0 0 1 5 0 0]</span>
<span class="sd">             [4 7 1 8 0 0]</span>
<span class="sd">             [0 0 0 0 0 0]</span>
<span class="sd">             [0 0 0 0 0 0]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_shape</span><span class="p">)</span>
    <span class="n">d_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dest_shape</span><span class="p">)</span>
    <span class="n">srcslices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">s_ndim</span>
    <span class="n">destslices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">d_ndim</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">s_ndim</span><span class="p">),</span> <span class="n">src_shape</span><span class="p">,</span> <span class="n">dest_shape</span><span class="p">,</span> <span class="n">srccenter</span><span class="p">,</span> <span class="n">destcenter</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span><span class="p">:</span>
            <span class="c1"># dimension before midpoint, clip to size fitting in both arrays</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dim</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">))</span>
            <span class="c1"># dimension after midpoint, clip to size fitting in both arrays</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dim</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ss</span> <span class="o">-</span> <span class="n">sc</span><span class="p">,</span> <span class="n">ds</span> <span class="o">-</span> <span class="n">dc</span><span class="p">))</span>

            <span class="n">srcslices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sc</span> <span class="o">-</span> <span class="n">d1</span><span class="p">,</span> <span class="n">sc</span> <span class="o">+</span> <span class="n">d2</span><span class="p">)</span>
            <span class="n">destslices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">dc</span> <span class="o">-</span> <span class="n">d1</span><span class="p">,</span> <span class="n">dc</span> <span class="o">+</span> <span class="n">d2</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">srcslices</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">destslices</span><span class="p">)</span></div>


<div class="viewcode-block" id="resize_center"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.resize_center">[docs]</a><span class="k">def</span> <span class="nf">resize_center</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">resize_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resize `img` by cropping or expanding the image from the center. The `resize_dims` values are the output dimensions</span>
<span class="sd">    (or None to use original dimension of `img`). If a dimension is smaller than that of `img` then the result will be</span>
<span class="sd">    cropped and if larger padded with zeros, in both cases this is done relative to the center of `img`. The result is</span>
<span class="sd">    a new image with the specified dimensions and values from `img` copied into its center.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">resize_dims</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">resize_dims</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">half_img_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">half_dest_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">resize_dims</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">srcslices</span><span class="p">,</span> <span class="n">destslices</span> <span class="o">=</span> <span class="n">copypaste_arrays</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">resize_dims</span><span class="p">,</span> <span class="n">half_img_shape</span><span class="p">,</span> <span class="n">half_dest_shape</span><span class="p">,</span> <span class="n">resize_dims</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">resize_dims</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">dest</span><span class="p">[</span><span class="n">destslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">srcslices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dest</span>
    <span class="k">return</span> <span class="n">img</span><span class="p">[</span><span class="n">srcslices</span><span class="p">]</span></div>


<div class="viewcode-block" id="map_binary_to_indices"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.map_binary_to_indices">[docs]</a><span class="k">def</span> <span class="nf">map_binary_to_indices</span><span class="p">(</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">image_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the foreground and background of input label data, return the indices after fattening.</span>
<span class="sd">    For example:</span>
<span class="sd">    ``label = np.array([[[0, 1, 1], [1, 0, 1], [1, 1, 0]]])``</span>
<span class="sd">    ``foreground indices = np.array([1, 2, 3, 5, 6, 7])`` and ``background indices = np.array([0, 4, 8])``</span>

<span class="sd">    Args:</span>
<span class="sd">        label: use the label data to get the foreground/background information.</span>
<span class="sd">        image: if image is not None, use ``label = 0 &amp; image &gt; image_threshold``</span>
<span class="sd">            to define background. so the output items will not map to all the voxels in the label.</span>
<span class="sd">        image_threshold: if enabled `image`, use ``image &gt; image_threshold`` to</span>
<span class="sd">            determine the valid image content area and select background only in this area.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prepare fg/bg indices</span>
    <span class="k">if</span> <span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># for One-Hot format data, remove the background channel</span>
    <span class="n">label_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># in case label has multiple dimensions</span>
    <span class="n">fg_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">label_flat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="n">image_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">bg_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">img_flat</span><span class="p">,</span> <span class="o">~</span><span class="n">label_flat</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bg_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">label_flat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fg_indices</span><span class="p">,</span> <span class="n">bg_indices</span></div>


<div class="viewcode-block" id="weighted_patch_samples"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.weighted_patch_samples">[docs]</a><span class="k">def</span> <span class="nf">weighted_patch_samples</span><span class="p">(</span>
    <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">r_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes `n_samples` of random patch sampling locations, given the sampling weight map `w` and patch `spatial_size`.</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_size: length of each spatial dimension of the patch.</span>
<span class="sd">        w: weight map, the weights must be non-negative. each element denotes a sampling weight of the spatial location.</span>
<span class="sd">            0 indicates no sampling.</span>
<span class="sd">            The weight map shape is assumed ``(spatial_dim_0, spatial_dim_1, ..., spatial_dim_n)``.</span>
<span class="sd">        n_samples: number of patch samples</span>
<span class="sd">        r_state: a random state container</span>

<span class="sd">    Returns:</span>
<span class="sd">        a list of `n_samples` N-D integers representing the spatial sampling location of patches.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;w must be an ND array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
    <span class="n">img_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">img_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">w</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">w</span> <span class="o">+</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">w</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">m</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">win_size</span><span class="p">,</span> <span class="n">img_size</span><span class="p">))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>  <span class="c1"># weight map in the &#39;valid&#39; mode</span>
    <span class="n">v_size</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># shifting to non-negative</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># uniform sampling</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">r_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">r_state</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
    <span class="c1"># compensate &#39;valid&#39; mode</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">win_size</span><span class="p">,</span> <span class="n">img_size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span></div>


<div class="viewcode-block" id="generate_pos_neg_label_crop_centers"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.generate_pos_neg_label_crop_centers">[docs]</a><span class="k">def</span> <span class="nf">generate_pos_neg_label_crop_centers</span><span class="p">(</span>
    <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pos_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">label_spatial_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">fg_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">bg_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">rand_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate valid sample locations based on the label with option for specifying foreground ratio</span>
<span class="sd">    Valid: samples sitting entirely within image, expected input shape: [C, H, W, D] or [C, H, W]</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_size: spatial size of the ROIs to be sampled.</span>
<span class="sd">        num_samples: total sample centers to be generated.</span>
<span class="sd">        pos_ratio: ratio of total locations generated that have center being foreground.</span>
<span class="sd">        label_spatial_shape: spatial shape of the original label data to unravel selected centers.</span>
<span class="sd">        fg_indices: pre-computed foreground indices in 1 dimension.</span>
<span class="sd">        bg_indices: pre-computed background indices in 1 dimension.</span>
<span class="sd">        rand_state: numpy randomState object to align with other modules.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: When the proposed roi is larger than the image.</span>
<span class="sd">        ValueError: When the foreground and background indices lengths are 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rand_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rand_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="vm">__self__</span>  <span class="c1"># type: ignore</span>
    <span class="n">spatial_size</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">label_spatial_shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">label_spatial_shape</span><span class="p">,</span> <span class="n">spatial_size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The size of the proposed random crop ROI is larger than the image size.&quot;</span><span class="p">)</span>

    <span class="c1"># Select subregion to assure valid roi</span>
    <span class="n">valid_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># add 1 for random</span>
    <span class="n">valid_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">label_spatial_shape</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">spatial_size</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
    <span class="c1"># int generation to have full range on upper side, but subtract unfloored size/2 to prevent rounded range</span>
    <span class="c1"># from being too high</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">valid_s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="n">valid_start</span>
    <span class="p">):</span>  <span class="c1"># need this because np.random.randint does not work with same start and end</span>
        <span class="k">if</span> <span class="n">valid_s</span> <span class="o">==</span> <span class="n">valid_end</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">valid_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_correct_centers</span><span class="p">(</span>
        <span class="n">center_ori</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">valid_start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">valid_end</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">center_ori</span><span class="p">):</span>
            <span class="n">center_i</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">valid_start</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">center_i</span> <span class="o">=</span> <span class="n">valid_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">valid_end</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">center_i</span> <span class="o">=</span> <span class="n">valid_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">center_ori</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">center_i</span>
        <span class="k">return</span> <span class="n">center_ori</span>

    <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fg_indices</span><span class="p">,</span> <span class="n">bg_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fg_indices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bg_indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fg_indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bg_indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No sampling location available.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fg_indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bg_indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;N foreground </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fg_indices</span><span class="p">)</span><span class="si">}</span><span class="s2">, N  background </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bg_indices</span><span class="p">)</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="s2">&quot;unable to generate class balanced samples.&quot;</span>
        <span class="p">)</span>
        <span class="n">pos_ratio</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">fg_indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
        <span class="n">indices_to_use</span> <span class="o">=</span> <span class="n">fg_indices</span> <span class="k">if</span> <span class="n">rand_state</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">pos_ratio</span> <span class="k">else</span> <span class="n">bg_indices</span>
        <span class="n">random_int</span> <span class="o">=</span> <span class="n">rand_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_to_use</span><span class="p">))</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">indices_to_use</span><span class="p">[</span><span class="n">random_int</span><span class="p">],</span> <span class="n">label_spatial_shape</span><span class="p">)</span>
        <span class="c1"># shift center to range of valid centers</span>
        <span class="n">center_ori</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_correct_centers</span><span class="p">(</span><span class="n">center_ori</span><span class="p">,</span> <span class="n">valid_start</span><span class="p">,</span> <span class="n">valid_end</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">centers</span></div>


<div class="viewcode-block" id="create_grid"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.create_grid">[docs]</a><span class="k">def</span> <span class="nf">create_grid</span><span class="p">(</span>
    <span class="n">spatial_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">spacing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">homogeneous</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute a `spatial_size` mesh.</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_size: spatial size of the grid.</span>
<span class="sd">        spacing: same len as ``spatial_size``, defaults to 1.0 (dense grid).</span>
<span class="sd">        homogeneous: whether to make homogeneous coordinates.</span>
<span class="sd">        dtype: output grid data type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spacing</span> <span class="o">=</span> <span class="n">spacing</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">(</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">spatial_size</span><span class="p">)</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spatial_size</span><span class="p">,</span> <span class="n">spacing</span><span class="p">)]</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">ranges</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">homogeneous</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coords</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">coords</span><span class="p">[:</span><span class="mi">1</span><span class="p">])])</span></div>


<div class="viewcode-block" id="create_control_grid"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.create_control_grid">[docs]</a><span class="k">def</span> <span class="nf">create_control_grid</span><span class="p">(</span>
    <span class="n">spatial_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">spacing</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">homogeneous</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="nb">float</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    control grid with two additional point in each direction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grid_shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">grid_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="mf">3.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">homogeneous</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_rotate"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.create_rotate">[docs]</a><span class="k">def</span> <span class="nf">create_rotate</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">radians</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a 2D or 3D rotation matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_dims: {``2``, ``3``} spatial rank</span>
<span class="sd">        radians: rotation radians</span>
<span class="sd">            when spatial_dims == 3, the `radians` sequence corresponds to</span>
<span class="sd">            rotation in the 1st, 2nd, and 3rd dim respectively.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: When ``radians`` is empty.</span>
<span class="sd">        ValueError: When ``spatial_dims`` is not one of [2, 3].</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radians</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sin_</span><span class="p">,</span> <span class="n">cos_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cos_</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">sin_</span><span class="p">,</span> <span class="n">cos_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radians must be non empty.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sin_</span><span class="p">,</span> <span class="n">cos_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cos_</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sin_</span><span class="p">,</span> <span class="n">cos_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sin_</span><span class="p">,</span> <span class="n">cos_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Affine should be a matrix.&quot;</span><span class="p">)</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">cos_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sin_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">sin_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">cos_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">sin_</span><span class="p">,</span> <span class="n">cos_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Affine should be a matrix.&quot;</span><span class="p">)</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">cos_</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">sin_</span><span class="p">,</span> <span class="n">cos_</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radians must be non empty.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">affine</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported spatial_dims: </span><span class="si">{</span><span class="n">spatial_dims</span><span class="si">}</span><span class="s2">, available options are [2, 3].&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_shear"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.create_shear">[docs]</a><span class="k">def</span> <span class="nf">create_shear</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">coefs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a shearing matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_dims: spatial rank</span>
<span class="sd">        coefs: shearing factors, defaults to 0.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotImplementedError: When ``spatial_dims`` is not one of [2, 3].</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">ensure_tuple_size</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pad_val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">coefs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">ensure_tuple_size</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">pad_val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">coefs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">coefs</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">coefs</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently only spatial_dims in [2, 3] are supported.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_scale"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.create_scale">[docs]</a><span class="k">def</span> <span class="nf">create_scale</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a scaling matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_dims: spatial rank</span>
<span class="sd">        scaling_factor: scaling factors, defaults to 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scaling_factor</span> <span class="o">=</span> <span class="n">ensure_tuple_size</span><span class="p">(</span><span class="n">scaling_factor</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">spatial_dims</span><span class="p">,</span> <span class="n">pad_val</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">scaling_factor</span><span class="p">[:</span><span class="n">spatial_dims</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,))</span></div>


<div class="viewcode-block" id="create_translate"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.create_translate">[docs]</a><span class="k">def</span> <span class="nf">create_translate</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    create a translation matrix</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_dims: spatial rank</span>
<span class="sd">        shift: translate factors, defaults to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shift</span><span class="p">[:</span><span class="n">spatial_dims</span><span class="p">]):</span>
        <span class="n">affine</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_spatial_bounding_box"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.generate_spatial_bounding_box">[docs]</a><span class="k">def</span> <span class="nf">generate_spatial_bounding_box</span><span class="p">(</span>
    <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">select_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">is_positive</span><span class="p">,</span>
    <span class="n">channel_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">IndexSelection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">margin</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate the spatial bounding box of foreground in the image with start-end positions.</span>
<span class="sd">    Users can define arbitrary function to select expected foreground from the whole image or specified channels.</span>
<span class="sd">    And it can also add margin to every dim of the bounding box.</span>
<span class="sd">    The output format of the coordinates is:</span>

<span class="sd">        [1st_spatial_dim_start, 2nd_spatial_dim_start, ..., Nth_spatial_dim_start],</span>
<span class="sd">        [1st_spatial_dim_end, 2nd_spatial_dim_end, ..., Nth_spatial_dim_end]</span>

<span class="sd">    The bounding boxes edges are aligned with the input image edges.</span>
<span class="sd">    This function returns [-1, -1, ...], [-1, -1, ...] if there&#39;s no positive intensity.</span>

<span class="sd">    Args:</span>
<span class="sd">        img: source image to generate bounding box from.</span>
<span class="sd">        select_fn: function to select expected foreground, default is to select values &gt; 0.</span>
<span class="sd">        channel_indices: if defined, select foreground only on the specified channels</span>
<span class="sd">            of image. if None, select foreground on the whole image.</span>
<span class="sd">        margin: add margin value to spatial dims of the bounding box, if only 1 value provided, use it for all dims.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ensure_tuple</span><span class="p">(</span><span class="n">channel_indices</span><span class="p">))]</span> <span class="k">if</span> <span class="n">channel_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">img</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">select_fn</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">margin</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;margin value should not be negative number.&quot;</span><span class="p">)</span>

    <span class="n">box_start</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="n">box_end</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>

    <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)),</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
            <span class="c1"># if no foreground, return all zero bounding box coords</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>

        <span class="n">min_d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">margin</span><span class="p">[</span><span class="n">di</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">max_d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">margin</span><span class="p">[</span><span class="n">di</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">min_d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">box_start</span><span class="p">[</span><span class="n">di</span><span class="p">],</span> <span class="n">box_end</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_d</span><span class="p">,</span> <span class="n">max_d</span>

    <span class="k">return</span> <span class="n">box_start</span><span class="p">,</span> <span class="n">box_end</span></div>


<div class="viewcode-block" id="get_largest_connected_component_mask"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.get_largest_connected_component_mask">[docs]</a><span class="k">def</span> <span class="nf">get_largest_connected_component_mask</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the largest connected component mask of an image.</span>

<span class="sd">    Args:</span>
<span class="sd">        img: Image to get largest connected component from. Shape is (spatial_dim1 [, spatial_dim2, ...])</span>
<span class="sd">        connectivity: Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor.</span>
<span class="sd">            Accepted values are ranging from  1 to input.ndim. If ``None``, a full</span>
<span class="sd">            connectivity of ``input.ndim`` is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img_arr</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">largest_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">img_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">img_arr</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">img_arr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">largest_cc</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_arr</span> <span class="o">==</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">img_arr</span><span class="o">.</span><span class="n">flat</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">largest_cc</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">device</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_extreme_points"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.get_extreme_points">[docs]</a><span class="k">def</span> <span class="nf">get_extreme_points</span><span class="p">(</span>
    <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">rand_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">background</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pert</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate extreme points from an image. These are used to generate initial segmentation</span>
<span class="sd">    for annotation models. An optional perturbation can be passed to simulate user clicks.</span>

<span class="sd">    Args:</span>
<span class="sd">        img:</span>
<span class="sd">            Image to generate extreme points from. Expected Shape is ``(spatial_dim1, [, spatial_dim2, ...])``.</span>
<span class="sd">        rand_state: `np.random.RandomState` object used to select random indices.</span>
<span class="sd">        background: Value to be consider as background, defaults to 0.</span>
<span class="sd">        pert: Random perturbation amount to add to the points, defaults to 0.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of extreme points, its length is equal to 2 * spatial dimension of input image.</span>
<span class="sd">        The output format of the coordinates is:</span>

<span class="sd">        [1st_spatial_dim_min, 1st_spatial_dim_max, 2nd_spatial_dim_min, ..., Nth_spatial_dim_max]</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: When the input image does not have any foreground pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rand_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rand_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="vm">__self__</span>  <span class="c1"># type: ignore</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">!=</span> <span class="n">background</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;get_extreme_points: no foreground object in mask!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_point</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select one of the indices within slice containing val.</span>

<span class="sd">        Args:</span>
<span class="sd">            val : value for comparison</span>
<span class="sd">            dim : dimension in which to look for value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">rand_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="c1"># add +- pert to each dimension</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pert</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand_state</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pt</span>

    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_get_point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">]),</span> <span class="n">i</span><span class="p">)))</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_get_point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">]),</span> <span class="n">i</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">points</span></div>


<div class="viewcode-block" id="extreme_points_to_image"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.extreme_points_to_image">[docs]</a><span class="k">def</span> <span class="nf">extreme_points_to_image</span><span class="p">(</span>
    <span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">rescale_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">rescale_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Please refer to :py:class:`monai.transforms.AddExtremePointsChannel` for the usage.</span>

<span class="sd">    Applies a gaussian filter to the extreme points image. Then the pixel values in points image are rescaled</span>
<span class="sd">    to range [rescale_min, rescale_max].</span>

<span class="sd">    Args:</span>
<span class="sd">        points: Extreme points of the object/organ.</span>
<span class="sd">        label: label image to get extreme points from. Shape must be</span>
<span class="sd">            (1, spatial_dim1, [, spatial_dim2, ...]). Doesn&#39;t support one-hot labels.</span>
<span class="sd">        sigma: if a list of values, must match the count of spatial dimensions of input data,</span>
<span class="sd">            and apply every value in the list to 1 spatial dimension. if only 1 value provided,</span>
<span class="sd">            use it for all spatial dimensions.</span>
<span class="sd">        rescale_min: minimum value of output data.</span>
<span class="sd">        rescale_max: maximum value of output data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># points to image</span>
    <span class="n">points_image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">points_image</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># add channel and add batch</span>
    <span class="n">points_image</span> <span class="o">=</span> <span class="n">points_image</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">gaussian_filter</span> <span class="o">=</span> <span class="n">GaussianFilter</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">points_image</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">points_image</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># rescale the points image to [rescale_min, rescale_max]</span>
    <span class="n">min_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points_image</span><span class="p">)</span>
    <span class="n">max_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points_image</span><span class="p">)</span>
    <span class="n">points_image</span> <span class="o">=</span> <span class="p">(</span><span class="n">points_image</span> <span class="o">-</span> <span class="n">min_intensity</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_intensity</span> <span class="o">-</span> <span class="n">min_intensity</span><span class="p">)</span>
    <span class="n">points_image</span> <span class="o">=</span> <span class="n">points_image</span> <span class="o">*</span> <span class="p">(</span><span class="n">rescale_max</span> <span class="o">-</span> <span class="n">rescale_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">rescale_min</span>
    <span class="k">return</span> <span class="n">points_image</span></div>


<div class="viewcode-block" id="map_spatial_axes"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.map_spatial_axes">[docs]</a><span class="k">def</span> <span class="nf">map_spatial_axes</span><span class="p">(</span>
    <span class="n">img_ndim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">spatial_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">channel_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to map the spatial axes to real axes in channel first/last shape.</span>
<span class="sd">    For example:</span>
<span class="sd">    If `channel_first` is True, and `img` has 3 spatial dims, map spatial axes to real axes as below:</span>
<span class="sd">    None -&gt; [1, 2, 3]</span>
<span class="sd">    [0, 1] -&gt; [1, 2]</span>
<span class="sd">    [0, -1] -&gt; [1, -1]</span>
<span class="sd">    If `channel_first` is False, and `img` has 3 spatial dims, map spatial axes to real axes as below:</span>
<span class="sd">    None -&gt; [0, 1, 2]</span>
<span class="sd">    [0, 1] -&gt; [0, 1]</span>
<span class="sd">    [0, -1] -&gt; [0, -2]</span>

<span class="sd">    Args:</span>
<span class="sd">        img_ndim: dimension number of the target image.</span>
<span class="sd">        spatial_axes: spatial axes to be converted, default is None.</span>
<span class="sd">            The default `None` will convert to all the spatial axes of the image.</span>
<span class="sd">            If axis is negative it counts from the last to the first axis.</span>
<span class="sd">            If axis is a tuple of ints.</span>
<span class="sd">        channel_first: the image data is channel first or channel last, default to channel first.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spatial_axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spatial_axes_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">img_ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">channel_first</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spatial_axes_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">spatial_axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">channel_first</span><span class="p">:</span>
                <span class="n">spatial_axes_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spatial_axes_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spatial_axes_</span></div>


<div class="viewcode-block" id="allow_missing_keys_mode"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.allow_missing_keys_mode">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">allow_missing_keys_mode</span><span class="p">(</span><span class="n">transform</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapTransform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">MapTransform</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Compose</span><span class="p">]]):</span>
    <span class="sd">&quot;&quot;&quot;Temporarily set all MapTransforms to not throw an error if keys are missing. After, revert to original states.</span>

<span class="sd">    Args:</span>
<span class="sd">        transform: either MapTransform or a Compose</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        data = {&quot;image&quot;: np.arange(16, dtype=float).reshape(1, 4, 4)}</span>
<span class="sd">        t = SpatialPadd([&quot;image&quot;, &quot;label&quot;], 10, allow_missing_keys=False)</span>
<span class="sd">        _ = t(data)  # would raise exception</span>
<span class="sd">        with allow_missing_keys_mode(t):</span>
<span class="sd">            _ = t(data)  # OK!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If given a sequence of transforms, Compose them to get a single list</span>
    <span class="k">if</span> <span class="n">issequenceiterable</span><span class="p">(</span><span class="n">transform</span><span class="p">):</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

    <span class="c1"># Get list of MapTransforms</span>
    <span class="n">transforms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">):</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">):</span>
        <span class="c1"># Only keep contained MapTransforms</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transform</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">transforms</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">MapTransform</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;allow_missing_keys_mode expects either MapTransform(s) or Compose(s) containing MapTransform(s)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Get the state of each `allow_missing_keys`</span>
    <span class="n">orig_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">allow_missing_keys</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Set all to True</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">allow_missing_keys</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Revert</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">o_s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span> <span class="n">orig_states</span><span class="p">):</span>
            <span class="n">t</span><span class="o">.</span><span class="n">allow_missing_keys</span> <span class="o">=</span> <span class="n">o_s</span></div>


<div class="viewcode-block" id="convert_inverse_interp_mode"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.convert_inverse_interp_mode">[docs]</a><span class="k">def</span> <span class="nf">convert_inverse_interp_mode</span><span class="p">(</span><span class="n">trans_info</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">align_corners</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the interpolation mode when inverting spatial transforms, default to &quot;nearest&quot;.</span>
<span class="sd">    This function modifies trans_info&#39;s `InverseKeys.EXTRA_INFO`.</span>

<span class="sd">    See also: :py:class:`monai.transform.inverse.InvertibleTransform`</span>

<span class="sd">    Args:</span>
<span class="sd">        trans_info: transforms inverse information list, contains context of every invertible transform.</span>
<span class="sd">        mode: target interpolation mode to convert, default to &quot;nearest&quot; as it&#39;s usually used to save the mode output.</span>
<span class="sd">        align_corners: target align corner value in PyTorch interpolation API, need to align with the `mode`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interp_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">InterpolateMode</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">GridSampleMode</span><span class="p">]</span>

    <span class="c1"># set to string for DataLoader collation</span>
    <span class="n">align_corners_</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span> <span class="k">if</span> <span class="n">align_corners</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">align_corners</span>

    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">trans_info</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">orig_mode</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">orig_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orig_mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">interp_modes</span><span class="p">:</span>
                    <span class="n">item</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mode</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">))]</span>
                <span class="k">elif</span> <span class="n">orig_mode</span> <span class="ow">in</span> <span class="n">interp_modes</span><span class="p">:</span>
                    <span class="n">item</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span>
            <span class="k">if</span> <span class="s2">&quot;align_corners&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">issequenceiterable</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]):</span>
                    <span class="n">item</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">align_corners_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">))]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">item</span><span class="p">[</span><span class="n">InverseKeys</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">][</span><span class="s2">&quot;align_corners&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">align_corners_</span>
    <span class="k">return</span> <span class="n">trans_info</span></div>


<div class="viewcode-block" id="compute_divisible_spatial_size"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.compute_divisible_spatial_size">[docs]</a><span class="k">def</span> <span class="nf">compute_divisible_spatial_size</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the target spatial size which should be divisible by `k`.</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_shape: original spatial shape.</span>
<span class="sd">        k: the target k for each spatial dimension.</span>
<span class="sd">            if `k` is negative or 0, the original size is preserved.</span>
<span class="sd">            if `k` is an int, the same `k` be applied to all the input spatial dimensions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">fall_back_tuple</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_shape</span><span class="p">))</span>
    <span class="n">new_size</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k_d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">spatial_shape</span><span class="p">):</span>
        <span class="n">new_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="n">k_d</span><span class="p">)</span> <span class="o">*</span> <span class="n">k_d</span><span class="p">)</span> <span class="k">if</span> <span class="n">k_d</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">dim</span>
        <span class="n">new_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_dim</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_size</span></div>


<div class="viewcode-block" id="convert_to_tensor"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.convert_to_tensor">[docs]</a><span class="k">def</span> <span class="nf">convert_to_tensor</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to convert the input data to a PyTorch Tensor. If passing a dictionary, list or tuple,</span>
<span class="sd">    recursively check every item and convert it to PyTorch Tensor.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: input data can be PyTorch Tensor, numpy array, list, dictionary, int, float, bool, str, etc.</span>
<span class="sd">            will convert Tensor, Numpy array, float, int, bool to Tensors, strings and objects keep the original.</span>
<span class="sd">            for dictionay, list or tuple, convert every item to a Tensor if applicable.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># skip array of string classes and object, refer to:</span>
        <span class="c1"># https://github.com/pytorch/pytorch/blob/v1.9.0/torch/utils/data/_utils/collate.py#L13</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[SaUO]&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># numpy array with 0 dims is also sequence iterable,</span>
            <span class="c1"># `ascontiguousarray` will add 1 dim if img has no dim, so we only apply on data with dims</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">data</span> <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="convert_to_numpy"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.convert_to_numpy">[docs]</a><span class="k">def</span> <span class="nf">convert_to_numpy</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to convert the input data to a numpy array. If passing a dictionary, list or tuple,</span>
<span class="sd">    recursively check every item and convert it to numpy array.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: input data can be PyTorch Tensor, numpy array, list, dictionary, int, float, bool, str, etc.</span>
<span class="sd">            will convert Tensor, Numpy array, float, int, bool to numpy arrays, strings and objects keep the original.</span>
<span class="sd">            for dictionay, list or tuple, convert every item to a numpy array if applicable.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">has_cp</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cp_ndarray</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="tensor_to_numpy"><a class="viewcode-back" href="../../../transforms.html#monai.transforms.utils.tensor_to_numpy">[docs]</a><span class="k">def</span> <span class="nf">tensor_to_numpy</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to convert the input PyTorch Tensor data to numpy array, if scalar Tensor, convert to regular number.</span>
<span class="sd">    If passing a dictionary, list or tuple, recursively check every PyTorch Tensor item and convert it to numpy arrays.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: input data can be PyTorch Tensor, numpy array, list, dictionary, int, float, bool, str, etc.</span>
<span class="sd">            will convert the Tensor data to numpy array, others keep the original. for dictionay, list or tuple,</span>
<span class="sd">            convert every Tensor item to numpy array if applicable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="c1"># invert Tensor to numpy, if scalar data, convert to number</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">tensor_to_numpy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tensor_to_numpy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">tensor_to_numpy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">data</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2021 MONAI Consortium.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>