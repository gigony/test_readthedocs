
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>monai.data.dataset &#8212; MONAI 0.6.0 Documentation</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/MONAI-logo-color.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../whatsnew.html">
  Whatâ€™s New
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../highlights.html">
  Modules Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../installation.html">
  Installation Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../contrib.html">
  Development
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/Project-MONAI/tutorials">Tutorials<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/project-monai/monai" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/projectmonai" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for monai.data.dataset</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020 - 2021 MONAI Consortium</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>


<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">multiprocessing.pool</span> <span class="kn">import</span> <span class="n">ThreadPool</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">IO</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span> <span class="k">as</span> <span class="n">_TorchDataset</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Subset</span>

<span class="kn">from</span> <span class="nn">monai.data.utils</span> <span class="kn">import</span> <span class="n">convert_tables_to_dicts</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">pickle_hashing</span>
<span class="kn">from</span> <span class="nn">monai.transforms</span> <span class="kn">import</span> <span class="n">Compose</span><span class="p">,</span> <span class="n">Randomizable</span><span class="p">,</span> <span class="n">ThreadUnsafe</span><span class="p">,</span> <span class="n">Transform</span><span class="p">,</span> <span class="n">apply_transform</span>
<span class="kn">from</span> <span class="nn">monai.utils</span> <span class="kn">import</span> <span class="n">MAX_SEED</span><span class="p">,</span> <span class="n">ensure_tuple</span><span class="p">,</span> <span class="n">get_seed</span><span class="p">,</span> <span class="n">min_version</span><span class="p">,</span> <span class="n">optional_import</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

    <span class="n">has_tqdm</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">tqdm</span><span class="p">,</span> <span class="n">has_tqdm</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;tqdm&quot;</span><span class="p">,</span> <span class="s2">&quot;4.47.0&quot;</span><span class="p">,</span> <span class="n">min_version</span><span class="p">,</span> <span class="s2">&quot;tqdm&quot;</span><span class="p">)</span>

<span class="n">lmdb</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;lmdb&quot;</span><span class="p">)</span>
<span class="n">pd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;pandas&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../../data.html#monai.data.Dataset">[docs]</a><span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span><span class="n">_TorchDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic dataset with a length property and an optional callable data transform</span>
<span class="sd">    when fetching a data sample.</span>
<span class="sd">    If passing slicing indices, will return a PyTorch Subset, for example: `data: Subset = dataset[1:4]`,</span>
<span class="sd">    for more details, please check: https://pytorch.org/docs/stable/data.html#torch.utils.data.Subset</span>

<span class="sd">    For example, typical input data can be a list of dictionaries::</span>

<span class="sd">        [{                            {                            {</span>
<span class="sd">             &#39;img&#39;: &#39;image1.nii.gz&#39;,      &#39;img&#39;: &#39;image2.nii.gz&#39;,      &#39;img&#39;: &#39;image3.nii.gz&#39;,</span>
<span class="sd">             &#39;seg&#39;: &#39;label1.nii.gz&#39;,      &#39;seg&#39;: &#39;label2.nii.gz&#39;,      &#39;seg&#39;: &#39;label3.nii.gz&#39;,</span>
<span class="sd">             &#39;extra&#39;: 123                 &#39;extra&#39;: 456                 &#39;extra&#39;: 789</span>
<span class="sd">         },                           },                           }]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Dataset.__init__"><a class="viewcode-back" href="../../../data.html#monai.data.Dataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            data: input data to load and transform to generate dataset for model.</span>
<span class="sd">            transform: a callable data transform on input data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetch single data item from `self.data`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">data_i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_i</span>

<div class="viewcode-block" id="Dataset.__getitem__"><a class="viewcode-back" href="../../../data.html#monai.data.Dataset.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a `Subset` if `index` is a slice or Sequence, a data item otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># dataset[:42]</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
            <span class="c1"># dataset[[1, 3, 4]]</span>
            <span class="k">return</span> <span class="n">Subset</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PersistentDataset"><a class="viewcode-back" href="../../../data.html#monai.data.PersistentDataset">[docs]</a><span class="k">class</span> <span class="nc">PersistentDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Persistent storage of pre-computed values to efficiently manage larger than memory dictionary format data,</span>
<span class="sd">    it can operate transforms for specific fields.  Results from the non-random transform components are computed</span>
<span class="sd">    when first used, and stored in the `cache_dir` for rapid retrieval on subsequent uses.</span>
<span class="sd">    If passing slicing indices, will return a PyTorch Subset, for example: `data: Subset = dataset[1:4]`,</span>
<span class="sd">    for more details, please check: https://pytorch.org/docs/stable/data.html#torch.utils.data.Subset</span>

<span class="sd">    For example, typical input data can be a list of dictionaries::</span>

<span class="sd">        [{                            {                            {</span>
<span class="sd">             &#39;image&#39;: &#39;image1.nii.gz&#39;,    &#39;image&#39;: &#39;image2.nii.gz&#39;,    &#39;image&#39;: &#39;image3.nii.gz&#39;,</span>
<span class="sd">             &#39;label&#39;: &#39;label1.nii.gz&#39;,    &#39;label&#39;: &#39;label2.nii.gz&#39;,    &#39;label&#39;: &#39;label3.nii.gz&#39;,</span>
<span class="sd">             &#39;extra&#39;: 123                 &#39;extra&#39;: 456                 &#39;extra&#39;: 789</span>
<span class="sd">         },                           },                           }]</span>

<span class="sd">    For a composite transform like</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        [ LoadImaged(keys=[&#39;image&#39;, &#39;label&#39;]),</span>
<span class="sd">          Orientationd(keys=[&#39;image&#39;, &#39;label&#39;], axcodes=&#39;RAS&#39;),</span>
<span class="sd">          ScaleIntensityRanged(keys=[&#39;image&#39;], a_min=-57, a_max=164, b_min=0.0, b_max=1.0, clip=True),</span>
<span class="sd">          RandCropByPosNegLabeld(keys=[&#39;image&#39;, &#39;label&#39;], label_key=&#39;label&#39;, spatial_size=(96, 96, 96),</span>
<span class="sd">                                 pos=1, neg=1, num_samples=4, image_key=&#39;image&#39;, image_threshold=0),</span>
<span class="sd">          ToTensord(keys=[&#39;image&#39;, &#39;label&#39;])]</span>

<span class="sd">    Upon first use a filename based dataset will be processed by the transform for the</span>
<span class="sd">    [LoadImaged, Orientationd, ScaleIntensityRanged] and the resulting tensor written to</span>
<span class="sd">    the `cache_dir` before applying the remaining random dependant transforms</span>
<span class="sd">    [RandCropByPosNegLabeld, ToTensord] elements for use in the analysis.</span>

<span class="sd">    Subsequent uses of a dataset directly read pre-processed results from `cache_dir`</span>
<span class="sd">    followed by applying the random dependant parts of transform processing.</span>

<span class="sd">    During training call `set_data()` to update input data and recompute cache content.</span>

<span class="sd">    Note:</span>
<span class="sd">        The input data must be a list of file paths and will hash them as cache keys.</span>

<span class="sd">        When loading persistent cache content, it can&#39;t guarantee the cached data matches current</span>
<span class="sd">        transform chain, so please make sure to use exactly the same non-random transforms and the</span>
<span class="sd">        args as the cache content, otherwise, it may cause unexpected errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PersistentDataset.__init__"><a class="viewcode-back" href="../../../data.html#monai.data.PersistentDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Callable</span><span class="p">],</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">hash_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle_hashing</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            data: input data file paths to load and transform to generate dataset for model.</span>
<span class="sd">                `PersistentDataset` expects input data to be a list of serializable</span>
<span class="sd">                and hashes them as cache keys using `hash_func`.</span>
<span class="sd">            transform: transforms to execute operations on input data.</span>
<span class="sd">            cache_dir: If specified, this is the location for persistent storage</span>
<span class="sd">                of pre-computed transformed data tensors. The cache_dir is computed once, and</span>
<span class="sd">                persists on disk until explicitly removed.  Different runs, programs, experiments</span>
<span class="sd">                may share a common cache dir provided that the transforms pre-processing is consistent.</span>
<span class="sd">                If `cache_dir` doesn&#39;t exist, will automatically create it.</span>
<span class="sd">                If `cache_dir` is `None`, there is effectively no caching.</span>
<span class="sd">            hash_func: a callable to compute hash from data items to be cached.</span>
<span class="sd">                defaults to `monai.data.utils.pickle_hashing`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">)</span> <span class="k">if</span> <span class="n">cache_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span> <span class="o">=</span> <span class="n">hash_func</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cache_dir must be a directory.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PersistentDataset.set_data"><a class="viewcode-back" href="../../../data.html#monai.data.PersistentDataset.set_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the input data and delete all the out-dated cache content.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_pre_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the data from original state up to the first random element.</span>

<span class="sd">        Args:</span>
<span class="sd">            item_transformed: The data to be transformed</span>

<span class="sd">        Returns:</span>
<span class="sd">            the transformed element up to the first identified</span>
<span class="sd">            random transform object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>  <span class="c1"># type:ignore</span>
            <span class="c1"># execute all the deterministic transforms</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Randomizable</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="c1"># this is to be consistent with CacheDataset even though it&#39;s not in a multi-thread situation.</span>
            <span class="n">_xform</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">_transform</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">ThreadUnsafe</span><span class="p">)</span> <span class="k">else</span> <span class="n">_transform</span>
            <span class="n">item_transformed</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="n">_xform</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item_transformed</span>

    <span class="k">def</span> <span class="nf">_post_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the data from before the first random transform to the final state ready for evaluation.</span>

<span class="sd">        Args:</span>
<span class="sd">            item_transformed: The data to be transformed (already processed up to the first random transform)</span>

<span class="sd">        Returns:</span>
<span class="sd">            the transformed element through the random transforms</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform must be an instance of monai.transforms.Compose.&quot;</span><span class="p">)</span>
        <span class="n">start_post_randomize_run</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">_transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">start_post_randomize_run</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Randomizable</span><span class="p">)</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">start_post_randomize_run</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">item_transformed</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item_transformed</span>

    <span class="k">def</span> <span class="nf">_cachecheck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function to cache the expensive input data transform operations</span>
<span class="sd">        so that huge data sets (larger than computer memory) can be processed</span>
<span class="sd">        on the fly as needed, and intermediate results written to disk for</span>
<span class="sd">        future use.</span>

<span class="sd">        Args:</span>
<span class="sd">            item_transformed: The current data element to be mutated into transformed representation</span>

<span class="sd">        Returns:</span>
<span class="sd">            The transformed data_element, either from cache, or explicitly computing it.</span>

<span class="sd">        Warning:</span>
<span class="sd">            The current implementation does not encode transform information as part of the</span>
<span class="sd">            hashing mechanism used for generating cache names.  If the transforms applied are</span>
<span class="sd">            changed in any way, the objects in the cache dir will be invalid.  The hash for the</span>
<span class="sd">            cache is ONLY dependant on the input filename paths.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hashfile</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_item_md5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span><span class="p">(</span><span class="n">item_transformed</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="n">hashfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">data_item_md5</span><span class="si">}</span><span class="s2">.pt&quot;</span>

        <span class="k">if</span> <span class="n">hashfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hashfile</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>  <span class="c1"># cache hit</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">hashfile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">PermissionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># windows machine multiprocessing not efficiently supported</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

        <span class="n">_item_transformed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_transform</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">item_transformed</span><span class="p">))</span>  <span class="c1"># keep the original hashed</span>
        <span class="k">if</span> <span class="n">hashfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># NOTE: Writing to a temporary directory and then using a nearly atomic rename operation</span>
            <span class="c1">#       to make the cache more robust to manual killing of parent process</span>
            <span class="c1">#       which may leave partially written cache files in an incomplete state</span>
            <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmpdirname</span><span class="p">:</span>
                <span class="n">temp_hash_file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">tmpdirname</span><span class="p">)</span> <span class="o">/</span> <span class="n">hashfile</span><span class="o">.</span><span class="n">name</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">_item_transformed</span><span class="p">,</span> <span class="n">temp_hash_file</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">temp_hash_file</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">hashfile</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                    <span class="c1"># On Unix, if target exists and is a file, it will be replaced silently if the user has permission.</span>
                    <span class="c1"># for more details: https://docs.python.org/3/library/shutil.html#shutil.move.</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">temp_hash_file</span><span class="p">,</span> <span class="n">hashfile</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">FileExistsError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">return</span> <span class="n">_item_transformed</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">pre_random_item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cachecheck</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_transform</span><span class="p">(</span><span class="n">pre_random_item</span><span class="p">)</span></div>


<div class="viewcode-block" id="CacheNTransDataset"><a class="viewcode-back" href="../../../data.html#monai.data.CacheNTransDataset">[docs]</a><span class="k">class</span> <span class="nc">CacheNTransDataset</span><span class="p">(</span><span class="n">PersistentDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extension of `PersistentDataset`, tt can also cache the result of first N transforms, no matter it&#39;s random or not.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CacheNTransDataset.__init__"><a class="viewcode-back" href="../../../data.html#monai.data.CacheNTransDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Callable</span><span class="p">],</span>
        <span class="n">cache_n_trans</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">hash_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle_hashing</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            data: input data file paths to load and transform to generate dataset for model.</span>
<span class="sd">                `PersistentDataset` expects input data to be a list of serializable</span>
<span class="sd">                and hashes them as cache keys using `hash_func`.</span>
<span class="sd">            transform: transforms to execute operations on input data.</span>
<span class="sd">            cache_n_trans: cache the result of first N transforms.</span>
<span class="sd">            cache_dir: If specified, this is the location for persistent storage</span>
<span class="sd">                of pre-computed transformed data tensors. The cache_dir is computed once, and</span>
<span class="sd">                persists on disk until explicitly removed.  Different runs, programs, experiments</span>
<span class="sd">                may share a common cache dir provided that the transforms pre-processing is consistent.</span>
<span class="sd">                If `cache_dir` doesn&#39;t exist, will automatically create it.</span>
<span class="sd">                If `cache_dir` is `None`, there is effectively no caching.</span>
<span class="sd">            hash_func: a callable to compute hash from data items to be cached.</span>
<span class="sd">                defaults to `monai.data.utils.pickle_hashing`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="n">hash_func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_n_trans</span> <span class="o">=</span> <span class="n">cache_n_trans</span></div>

    <span class="k">def</span> <span class="nf">_pre_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the data from original state up to the N element.</span>

<span class="sd">        Args:</span>
<span class="sd">            item_transformed: The data to be transformed</span>

<span class="sd">        Returns:</span>
<span class="sd">            the transformed element up to the N transform object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform must be an instance of monai.transforms.Compose.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_transform</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">transforms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_n_trans</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">_xform</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">_transform</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">ThreadUnsafe</span><span class="p">)</span> <span class="k">else</span> <span class="n">_transform</span>
            <span class="n">item_transformed</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="n">_xform</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item_transformed</span>

    <span class="k">def</span> <span class="nf">_post_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the data from before the N + 1 transform to the final state ready for evaluation.</span>

<span class="sd">        Args:</span>
<span class="sd">            item_transformed: The data to be transformed (already processed up to the first N transform)</span>

<span class="sd">        Returns:</span>
<span class="sd">            the final transformed result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform must be an instance of monai.transforms.Compose.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_transform</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">transforms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_n_trans</span><span class="p">:</span>
                <span class="n">item_transformed</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item_transformed</span></div>


<div class="viewcode-block" id="LMDBDataset"><a class="viewcode-back" href="../../../data.html#monai.data.LMDBDataset">[docs]</a><span class="k">class</span> <span class="nc">LMDBDataset</span><span class="p">(</span><span class="n">PersistentDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extension of `PersistentDataset` using LMDB as the backend.</span>

<span class="sd">    See Also:</span>
<span class="sd">        :py:class:`monai.data.PersistentDataset`</span>

<span class="sd">    Examples:</span>

<span class="sd">        &gt;&gt;&gt; items = [{&quot;data&quot;: i} for i in range(5)]</span>
<span class="sd">        # [{&#39;data&#39;: 0}, {&#39;data&#39;: 1}, {&#39;data&#39;: 2}, {&#39;data&#39;: 3}, {&#39;data&#39;: 4}]</span>
<span class="sd">        &gt;&gt;&gt; lmdb_ds = monai.data.LMDBDataset(items, transform=monai.transforms.SimulateDelayd(&quot;data&quot;, delay_time=1))</span>
<span class="sd">        &gt;&gt;&gt; print(list(lmdb_ds))  # using the cached results</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LMDBDataset.__init__"><a class="viewcode-back" href="../../../data.html#monai.data.LMDBDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Callable</span><span class="p">],</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cache&quot;</span><span class="p">,</span>
        <span class="n">hash_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle_hashing</span><span class="p">,</span>
        <span class="n">db_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;monai_cache&quot;</span><span class="p">,</span>
        <span class="n">progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pickle_protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
        <span class="n">lmdb_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            data: input data file paths to load and transform to generate dataset for model.</span>
<span class="sd">                `LMDBDataset` expects input data to be a list of serializable</span>
<span class="sd">                and hashes them as cache keys using `hash_func`.</span>
<span class="sd">            transform: transforms to execute operations on input data.</span>
<span class="sd">            cache_dir: if specified, this is the location for persistent storage</span>
<span class="sd">                of pre-computed transformed data tensors. The cache_dir is computed once, and</span>
<span class="sd">                persists on disk until explicitly removed.  Different runs, programs, experiments</span>
<span class="sd">                may share a common cache dir provided that the transforms pre-processing is consistent.</span>
<span class="sd">                If the cache_dir doesn&#39;t exist, will automatically create it. Defaults to &quot;./cache&quot;.</span>
<span class="sd">            hash_func: a callable to compute hash from data items to be cached.</span>
<span class="sd">                defaults to `monai.data.utils.pickle_hashing`.</span>
<span class="sd">            db_name: lmdb database file name. Defaults to &quot;monai_cache&quot;.</span>
<span class="sd">            progress: whether to display a progress bar.</span>
<span class="sd">            pickle_protocol: pickle protocol version. Defaults to pickle.HIGHEST_PROTOCOL.</span>
<span class="sd">                https://docs.python.org/3/library/pickle.html#pickle-protocols</span>
<span class="sd">            lmdb_kwargs: additional keyword arguments to the lmdb environment.</span>
<span class="sd">                for more details please visit: https://lmdb.readthedocs.io/en/release/#environment-class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="n">hash_func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cache_dir must be specified.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">db_name</span><span class="si">}</span><span class="s2">.lmdb&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pickle_protocol</span> <span class="o">=</span> <span class="n">pickle_protocol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span> <span class="o">=</span> <span class="n">lmdb_kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;map_size&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">[</span><span class="s2">&quot;map_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">4</span>  <span class="c1"># default map_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Accessing lmdb file: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">db_file</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMDBDataset.set_data"><a class="viewcode-back" href="../../../data.html#monai.data.LMDBDataset.set_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the input data and delete all the out-dated cache content.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_fill_cache_start_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">[</span><span class="s2">&quot;readonly&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">lmdb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">db_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">subdir</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_tqdm</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;LMDBDataset: tqdm is not installed. not displaying the caching progress.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_tqdm</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">done</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span> <span class="ow">and</span> <span class="n">retry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">env</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">txn</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">txn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
                            <span class="n">done</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
                                <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_transform</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>  <span class="c1"># keep the original hashed</span>
                            <span class="n">val</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pickle_protocol</span><span class="p">)</span>
                        <span class="n">txn</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="n">lmdb</span><span class="o">.</span><span class="n">MapFullError</span><span class="p">:</span>
                    <span class="n">done</span><span class="p">,</span> <span class="n">retry</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">retry</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">size</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="s2">&quot;map_size&quot;</span><span class="p">]</span>
                    <span class="n">new_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resizing the cache database from </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="si">}</span><span class="s2">MB to </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">new_size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="si">}</span><span class="s2">MB.&quot;</span><span class="p">)</span>
                    <span class="n">env</span><span class="o">.</span><span class="n">set_mapsize</span><span class="p">(</span><span class="n">new_size</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">lmdb</span><span class="o">.</span><span class="n">MapResizedError</span><span class="p">:</span>
                    <span class="c1"># the mapsize is increased by another process</span>
                    <span class="c1"># set_mapsize with a size of 0 to adopt the new size,</span>
                    <span class="n">env</span><span class="o">.</span><span class="n">set_mapsize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>  <span class="c1"># still has the map full error</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="s2">&quot;map_size&quot;</span><span class="p">]</span>
                <span class="n">env</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LMDB map size reached, increase size above current size of </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="s2">&quot;map_size&quot;</span><span class="p">]</span>
        <span class="n">env</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># read-only database env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">[</span><span class="s2">&quot;readonly&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">[</span><span class="s2">&quot;map_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lock&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">[</span><span class="s2">&quot;lock&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;readahead&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">[</span><span class="s2">&quot;readahead&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">lmdb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">db_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">subdir</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">lmdb_kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cachecheck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_transformed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if the item is not found in the lmdb file, resolves to the persistent cache default behaviour.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache_start_reader</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">txn</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">txn</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span><span class="p">(</span><span class="n">item_transformed</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;LMDBDataset: cache key not found, running fallback caching.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_cachecheck</span><span class="p">(</span><span class="n">item_transformed</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid cache value, corrupted lmdb file?&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

<div class="viewcode-block" id="LMDBDataset.info"><a class="viewcode-back" href="../../../data.html#monai.data.LMDBDataset.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns: dataset info dictionary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache_start_reader</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_env</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">db_file</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="CacheDataset"><a class="viewcode-back" href="../../../data.html#monai.data.CacheDataset">[docs]</a><span class="k">class</span> <span class="nc">CacheDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dataset with cache mechanism that can load data and cache deterministic transforms&#39; result during training.</span>

<span class="sd">    By caching the results of non-random preprocessing transforms, it accelerates the training data pipeline.</span>
<span class="sd">    If the requested data is not in the cache, all transforms will run normally</span>
<span class="sd">    (see also :py:class:`monai.data.dataset.Dataset`).</span>

<span class="sd">    Users can set the cache rate or number of items to cache.</span>
<span class="sd">    It is recommended to experiment with different `cache_num` or `cache_rate` to identify the best training speed.</span>

<span class="sd">    To improve the caching efficiency, please always put as many as possible non-random transforms</span>
<span class="sd">    before the randomized ones when composing the chain of transforms.</span>
<span class="sd">    If passing slicing indices, will return a PyTorch Subset, for example: `data: Subset = dataset[1:4]`,</span>
<span class="sd">    for more details, please check: https://pytorch.org/docs/stable/data.html#torch.utils.data.Subset</span>

<span class="sd">    For example, if the transform is a `Compose` of::</span>

<span class="sd">        transforms = Compose([</span>
<span class="sd">            LoadImaged(),</span>
<span class="sd">            AddChanneld(),</span>
<span class="sd">            Spacingd(),</span>
<span class="sd">            Orientationd(),</span>
<span class="sd">            ScaleIntensityRanged(),</span>
<span class="sd">            RandCropByPosNegLabeld(),</span>
<span class="sd">            ToTensord()</span>
<span class="sd">        ])</span>

<span class="sd">    when `transforms` is used in a multi-epoch training pipeline, before the first training epoch,</span>
<span class="sd">    this dataset will cache the results up to ``ScaleIntensityRanged``, as</span>
<span class="sd">    all non-random transforms `LoadImaged`, `AddChanneld`, `Spacingd`, `Orientationd`, `ScaleIntensityRanged`</span>
<span class="sd">    can be cached. During training, the dataset will load the cached results and run</span>
<span class="sd">    ``RandCropByPosNegLabeld`` and ``ToTensord``, as ``RandCropByPosNegLabeld`` is a randomized transform</span>
<span class="sd">    and the outcome not cached.</span>

<span class="sd">    During training call `set_data()` to update input data and recompute cache content, note that it requires</span>
<span class="sd">    `persistent_workers=False` in the PyTorch DataLoader.</span>

<span class="sd">    Note:</span>
<span class="sd">        `CacheDataset` executes non-random transforms and prepares cache content in the main process before</span>
<span class="sd">        the first epoch, then all the subprocesses of DataLoader will read the same cache content in the main process</span>
<span class="sd">        during training. it may take a long time to prepare cache content according to the size of expected cache data.</span>
<span class="sd">        So to debug or verify the program before real training, users can set `cache_rate=0.0` or `cache_num=0` to</span>
<span class="sd">        temporarily skip caching.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CacheDataset.__init__"><a class="viewcode-back" href="../../../data.html#monai.data.CacheDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Callable</span><span class="p">],</span>
        <span class="n">cache_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">,</span>
        <span class="n">cache_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">num_workers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            data: input data to load and transform to generate dataset for model.</span>
<span class="sd">            transform: transforms to execute operations on input data.</span>
<span class="sd">            cache_num: number of items to be cached. Default is `sys.maxsize`.</span>
<span class="sd">                will take the minimum of (cache_num, data_length x cache_rate, data_length).</span>
<span class="sd">            cache_rate: percentage of cached data in total, default is 1.0 (cache all).</span>
<span class="sd">                will take the minimum of (cache_num, data_length x cache_rate, data_length).</span>
<span class="sd">            num_workers: the number of worker processes to use.</span>
<span class="sd">                If num_workers is None then the number returned by os.cpu_count() is used.</span>
<span class="sd">            progress: whether to display a progress bar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cache_num</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">cache_rate</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="o">=</span> <span class="n">num_workers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">()</span></div>

<div class="viewcode-block" id="CacheDataset.set_data"><a class="viewcode-back" href="../../../data.html#monai.data.CacheDataset.set_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the input data and run deterministic transforms to generate cache content.</span>

<span class="sd">        Note: should call this func after an entire epoch and must set `persisten_workers=False`</span>
<span class="sd">        in PyTorch DataLoader, because it needs to create new worker processes based on new</span>
<span class="sd">        generated cache content.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_fill_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_tqdm</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;tqdm is not installed, will not show the caching progress bar.&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress</span> <span class="ow">and</span> <span class="n">has_tqdm</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">tqdm</span><span class="p">(</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load_cache_item</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span><span class="p">)),</span>
                        <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span><span class="p">,</span>
                        <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Loading dataset&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load_cache_item</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_load_cache_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            idx: the index of the input data sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>  <span class="c1"># type:ignore</span>
            <span class="c1"># execute all the deterministic transforms</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Randomizable</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">_xform</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">_transform</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">ThreadUnsafe</span><span class="p">)</span> <span class="k">else</span> <span class="n">_transform</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="n">_xform</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span><span class="p">:</span>  <span class="c1"># support negative index</span>
            <span class="c1"># no cache for this index, execute all the transforms directly</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="c1"># load data from cache and execute from the first random transform</span>
        <span class="n">start_run</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">Compose</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform must be an instance of monai.transforms.Compose.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start_run</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Randomizable</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
                <span class="c1"># only need to deep copy data on first non-deterministic transform</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">start_run</span><span class="p">:</span>
                    <span class="n">start_run</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="SmartCacheDataset"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset">[docs]</a><span class="k">class</span> <span class="nc">SmartCacheDataset</span><span class="p">(</span><span class="n">Randomizable</span><span class="p">,</span> <span class="n">CacheDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-implementation of the SmartCache mechanism in NVIDIA Clara-train SDK.</span>
<span class="sd">    At any time, the cache pool only keeps a subset of the whole dataset. In each epoch, only the items</span>
<span class="sd">    in the cache are used for training. This ensures that data needed for training is readily available,</span>
<span class="sd">    keeping GPU resources busy. Note that cached items may still have to go through a non-deterministic</span>
<span class="sd">    transform sequence before being fed to GPU. At the same time, another thread is preparing replacement</span>
<span class="sd">    items by applying the transform sequence to items not in cache. Once one epoch is completed, Smart</span>
<span class="sd">    Cache replaces the same number of items with replacement items.</span>
<span class="sd">    Smart Cache uses a simple `running window` algorithm to determine the cache content and replacement items.</span>
<span class="sd">    Let N be the configured number of objects in cache; and R be the number of replacement objects (R = ceil(N * r),</span>
<span class="sd">    where r is the configured replace rate).</span>
<span class="sd">    For more details, please refer to:</span>
<span class="sd">    https://docs.nvidia.com/clara/tlt-mi/clara-train-sdk-v3.0/nvmidl/additional_features/smart_cache.html#smart-cache</span>
<span class="sd">    If passing slicing indices, will return a PyTorch Subset, for example: `data: Subset = dataset[1:4]`,</span>
<span class="sd">    for more details, please check: https://pytorch.org/docs/stable/data.html#torch.utils.data.Subset</span>

<span class="sd">    For example, if we have 5 images: `[image1, image2, image3, image4, image5]`, and `cache_num=4`, `replace_rate=0.25`.</span>
<span class="sd">    so the actual training images cached and replaced for every epoch are as below::</span>

<span class="sd">        epoch 1: [image1, image2, image3, image4]</span>
<span class="sd">        epoch 2: [image2, image3, image4, image5]</span>
<span class="sd">        epoch 3: [image3, image4, image5, image1]</span>
<span class="sd">        epoch 3: [image4, image5, image1, image2]</span>
<span class="sd">        epoch N: [image[N % 5] ...]</span>

<span class="sd">    The usage of `SmartCacheDataset` contains 4 steps:</span>

<span class="sd">        1. Initialize `SmartCacheDataset` object and cache for the first epoch.</span>
<span class="sd">        2. Call `start()` to run replacement thread in background.</span>
<span class="sd">        3. Call `update_cache()` before every epoch to replace training items.</span>
<span class="sd">        4. Call `shutdown()` when training ends.</span>

<span class="sd">    During training call `set_data()` to update input data and recompute cache content, note to call</span>
<span class="sd">    `shutdown()` to stop first, then update data and call `start()` to restart.</span>

<span class="sd">    Note:</span>
<span class="sd">        This replacement will not work for below cases:</span>
<span class="sd">        1. Set the `multiprocessing_context` of DataLoader to `spawn`.</span>
<span class="sd">        2. Run on windows(the default multiprocessing method is `spawn`) with `num_workers` greater than 0.</span>
<span class="sd">        3. Set the `persistent_workers` of DataLoader to `True` with `num_workers` greater than 0.</span>

<span class="sd">        If using MONAI workflows, please add `SmartCacheHandler` to the handler list of trainer,</span>
<span class="sd">        otherwise, please make sure to call `start()`, `update_cache()`, `shutdown()` during training.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: input data to load and transform to generate dataset for model.</span>
<span class="sd">        transform: transforms to execute operations on input data.</span>
<span class="sd">        replace_rate: percentage of the cached items to be replaced in every epoch.</span>
<span class="sd">        cache_num: number of items to be cached. Default is `sys.maxsize`.</span>
<span class="sd">            will take the minimum of (cache_num, data_length x cache_rate, data_length).</span>
<span class="sd">        cache_rate: percentage of cached data in total, default is 1.0 (cache all).</span>
<span class="sd">            will take the minimum of (cache_num, data_length x cache_rate, data_length).</span>
<span class="sd">        num_init_workers: the number of worker threads to initialize the cache for first epoch.</span>
<span class="sd">            If num_init_workers is None then the number returned by os.cpu_count() is used.</span>
<span class="sd">        num_replace_workers: the number of worker threads to prepare the replacement cache for every epoch.</span>
<span class="sd">            If num_replace_workers is None then the number returned by os.cpu_count() is used.</span>
<span class="sd">        progress: whether to display a progress bar when caching for the first epoch.</span>
<span class="sd">        shuffle: whether to shuffle the whole data list before preparing the cache content for first epoch.</span>
<span class="sd">            it will not modify the original input data sequence in-place.</span>
<span class="sd">        seed: random seed if shuffle is `True`, default to `0`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Callable</span><span class="p">],</span>
        <span class="n">replace_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">cache_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">,</span>
        <span class="n">cache_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">num_init_workers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num_replace_workers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">cache_num</span><span class="p">,</span> <span class="n">cache_rate</span><span class="p">,</span> <span class="n">num_init_workers</span><span class="p">,</span> <span class="n">progress</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;cache_num is greater or equal than dataset length, fall back to regular monai.data.CacheDataset.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">replace_rate</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;replace_rate must be greater than 0, otherwise, please use monai.data.CacheDataset.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_replace_workers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_replace_workers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_replace_workers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_replace_workers</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_replace_workers</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_total_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span> <span class="o">*</span> <span class="n">replace_rate</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replacements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replace_num</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_data_idx</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replace_num</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start_pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_lock</span><span class="p">:</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_done</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_data_idx</span><span class="p">()</span>

<div class="viewcode-block" id="SmartCacheDataset.set_data"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset.set_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the input data and run deterministic transforms to generate cache content.</span>

<span class="sd">        Note: should call `shutdown()` before calling this func.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_started</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;SmartCacheDataset is not shutdown yet, shutdown it directly.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmartCacheDataset.randomize"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input data can&#39;t be shuffled in SmartCacheDataset with numpy.random.shuffle(): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_compute_data_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the replacement data position in the total data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replace_num</span><span class="p">):</span>
            <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_num</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_num</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_replace_data_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>

<div class="viewcode-block" id="SmartCacheDataset.is_started"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset.is_started">[docs]</a>    <span class="k">def</span> <span class="nf">is_started</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the replacement thread is already started.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span><span class="o">.</span><span class="n">is_alive</span><span class="p">()</span></div>

<div class="viewcode-block" id="SmartCacheDataset.start"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start the background thread to replace training items for every epoch.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_started</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart background thread if killed for some reason.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_round</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">manage_replacement</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_try_update_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the cache items with new replacement for current epoch.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_done</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_num</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replacements</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_start_pos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_num</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_pos</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_num</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start_pos</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_num</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_data_idx</span><span class="p">()</span>

            <span class="c1"># ready for next round</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_round</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_replace_done</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="SmartCacheDataset.update_cache"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset.update_cache">[docs]</a>    <span class="k">def</span> <span class="nf">update_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update cache items for current epoch, need to call this function before every epoch.</span>
<span class="sd">        If the cache has been shutdown before, need to restart the `_replace_mgr` thread.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

        <span class="c1"># make sure update is done</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_update_cache</span><span class="p">():</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_try_shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait for thread lock to shut down the background thread.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_done</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_round</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start_pos</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_data_idx</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replace_done</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="SmartCacheDataset.shutdown"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset.shutdown">[docs]</a>    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shut down the background thread for replacement.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_started</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c1"># wait until replace mgr is done the current round</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_shutdown</span><span class="p">():</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_mgr</span><span class="o">.</span><span class="n">join</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_replace_cache_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute deterministic transforms on the new data for replacement.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_data_idx</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replacements</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_cache_item</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_replacements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute expected items for the replacement of next epoch, execute deterministic transforms.</span>
<span class="sd">        It can support multi-threads to accelerate the computation progress.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_replace_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replace_cache_thread</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replace_num</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_done</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_try_manage_replacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check_round</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait thread lock and replace training items in the background thread.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># shutdown replacement</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replace_done</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span> <span class="o">!=</span> <span class="n">check_round</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_replacements</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span>

<div class="viewcode-block" id="SmartCacheDataset.manage_replacement"><a class="viewcode-back" href="../../../data.html#monai.data.SmartCacheDataset.manage_replacement">[docs]</a>    <span class="k">def</span> <span class="nf">manage_replacement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Background thread for replacement.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_round</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">done</span><span class="p">,</span> <span class="n">check_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_manage_replacement</span><span class="p">(</span><span class="n">check_round</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dataset length is given by cache_num instead of len(data).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_num</span></div>


<div class="viewcode-block" id="ZipDataset"><a class="viewcode-back" href="../../../data.html#monai.data.ZipDataset">[docs]</a><span class="k">class</span> <span class="nc">ZipDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zip several PyTorch datasets and output data(with the same index) together in a tuple.</span>
<span class="sd">    If the output of single dataset is already a tuple, flatten it and extend to the result.</span>
<span class="sd">    For example: if datasetA returns (img, imgmeta), datasetB returns (seg, segmeta),</span>
<span class="sd">    finally return (img, imgmeta, seg, segmeta).</span>
<span class="sd">    And if the datasets don&#39;t have same length, use the minimum length of them as the length</span>
<span class="sd">    of ZipDataset.</span>
<span class="sd">    If passing slicing indices, will return a PyTorch Subset, for example: `data: Subset = dataset[1:4]`,</span>
<span class="sd">    for more details, please check: https://pytorch.org/docs/stable/data.html#torch.utils.data.Subset</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; zip_data = ZipDataset([[1, 2, 3], [4, 5]])</span>
<span class="sd">        &gt;&gt;&gt; print(len(zip_data))</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; for item in zip_data:</span>
<span class="sd">        &gt;&gt;&gt;    print(item)</span>
<span class="sd">        [1, 4]</span>
<span class="sd">        [2, 5]</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ZipDataset.__init__"><a class="viewcode-back" href="../../../data.html#monai.data.ZipDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasets</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            datasets: list of datasets to zip together.</span>
<span class="sd">            transform: a callable data transform operates on the zipped item from `datasets`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">datasets</span><span class="p">),</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">to_list</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">map_items</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># transform the list data</span>
        <span class="c1"># use tuple instead of list as the default collate_fn callback of MONAI DataLoader flattens nested lists</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="ArrayDataset"><a class="viewcode-back" href="../../../data.html#monai.data.ArrayDataset">[docs]</a><span class="k">class</span> <span class="nc">ArrayDataset</span><span class="p">(</span><span class="n">Randomizable</span><span class="p">,</span> <span class="n">_TorchDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dataset for segmentation and classification tasks based on array format input data and transforms.</span>
<span class="sd">    It ensures the same random seeds in the randomized transforms defined for image, segmentation and label.</span>
<span class="sd">    The `transform` can be :py:class:`monai.transforms.Compose` or any other callable object.</span>
<span class="sd">    For example:</span>
<span class="sd">    If train based on Nifti format images without metadata, all transforms can be composed::</span>

<span class="sd">        img_transform = Compose(</span>
<span class="sd">            [</span>
<span class="sd">                LoadImage(image_only=True),</span>
<span class="sd">                AddChannel(),</span>
<span class="sd">                RandAdjustContrast()</span>
<span class="sd">            ]</span>
<span class="sd">        )</span>
<span class="sd">        ArrayDataset(img_file_list, img_transform=img_transform)</span>

<span class="sd">    If training based on images and the metadata, the array transforms can not be composed</span>
<span class="sd">    because several transforms receives multiple parameters or return multiple values. Then Users need</span>
<span class="sd">    to define their own callable method to parse metadata from `LoadImage` or set `affine` matrix</span>
<span class="sd">    to `Spacing` transform::</span>

<span class="sd">        class TestCompose(Compose):</span>
<span class="sd">            def __call__(self, input_):</span>
<span class="sd">                img, metadata = self.transforms[0](input_)</span>
<span class="sd">                img = self.transforms[1](img)</span>
<span class="sd">                img, _, _ = self.transforms[2](img, metadata[&quot;affine&quot;])</span>
<span class="sd">                return self.transforms[3](img), metadata</span>
<span class="sd">        img_transform = TestCompose(</span>
<span class="sd">            [</span>
<span class="sd">                LoadImage(image_only=False),</span>
<span class="sd">                AddChannel(),</span>
<span class="sd">                Spacing(pixdim=(1.5, 1.5, 3.0)),</span>
<span class="sd">                RandAdjustContrast()</span>
<span class="sd">            ]</span>
<span class="sd">        )</span>
<span class="sd">        ArrayDataset(img_file_list, img_transform=img_transform)</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; ds = ArrayDataset([1, 2, 3, 4], lambda x: x + 0.1)</span>
<span class="sd">        &gt;&gt;&gt; print(ds[0])</span>
<span class="sd">        1.1</span>

<span class="sd">        &gt;&gt;&gt; ds = ArrayDataset(img=[1, 2, 3, 4], seg=[5, 6, 7, 8])</span>
<span class="sd">        &gt;&gt;&gt; print(ds[0])</span>
<span class="sd">        [1, 5]</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ArrayDataset.__init__"><a class="viewcode-back" href="../../../data.html#monai.data.ArrayDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
        <span class="n">img_transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">seg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">seg_transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label_transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the dataset with the filename lists. The transform `img_transform` is applied</span>
<span class="sd">        to the images and `seg_transform` to the segmentations.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: sequence of images.</span>
<span class="sd">            img_transform: transform to apply to each element in `img`.</span>
<span class="sd">            seg: sequence of segmentations.</span>
<span class="sd">            seg_transform: transform to apply to each element in `seg`.</span>
<span class="sd">            labels: sequence of labels.</span>
<span class="sd">            label_transform: transform to apply to each element in `labels`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">img</span><span class="p">,</span> <span class="n">img_transform</span><span class="p">),</span> <span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">seg_transform</span><span class="p">),</span> <span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">label_transform</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">get_seed</span><span class="p">())</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dataset</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">ZipDataset</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># transform synchronization seed</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>

<div class="viewcode-block" id="ArrayDataset.randomize"><a class="viewcode-back" href="../../../data.html#monai.data.ArrayDataset.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MAX_SEED</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="n">ZipDataset</span><span class="p">):</span>
            <span class="c1"># set transforms of each zip component</span>
            <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Randomizable</span><span class="p">):</span>
                    <span class="n">transform</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_seed</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Randomizable</span><span class="p">):</span>
            <span class="n">transform</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>


<div class="viewcode-block" id="NPZDictItemDataset"><a class="viewcode-back" href="../../../data.html#monai.data.NPZDictItemDataset">[docs]</a><span class="k">class</span> <span class="nc">NPZDictItemDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a dataset from a loaded NPZ file. The members of the file to load are named in the keys of `keys` and</span>
<span class="sd">    stored under the keyed name. All loaded arrays must have the same 0-dimension (batch) size. Items are always dicts</span>
<span class="sd">    mapping names to an item extracted from the loaded arrays.</span>
<span class="sd">    If passing slicing indices, will return a PyTorch Subset, for example: `data: Subset = dataset[1:4]`,</span>
<span class="sd">    for more details, please check: https://pytorch.org/docs/stable/data.html#torch.utils.data.Subset</span>

<span class="sd">    Args:</span>
<span class="sd">        npzfile: Path to .npz file or stream containing .npz file data</span>
<span class="sd">        keys: Maps keys to load from file to name to store in dataset</span>
<span class="sd">        transform: Transform to apply to batch dict</span>
<span class="sd">        other_keys: secondary data to load from file and store in dict `other_keys`, not returned by __getitem__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">npzfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">IO</span><span class="p">],</span>
        <span class="n">keys</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">other_keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npzfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">IO</span><span class="p">]</span> <span class="o">=</span> <span class="n">npzfile</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">npzfile</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;STREAM&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">npzfile</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="p">{</span><span class="n">storedk</span><span class="p">:</span> <span class="n">dat</span><span class="p">[</span><span class="n">datak</span><span class="p">]</span> <span class="k">for</span> <span class="n">datak</span><span class="p">,</span> <span class="n">storedk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">first</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">other_keys</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">other_keys</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">dat</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other_keys</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;All loaded arrays must have the same first dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="si">}</span><span class="s2">, array `</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">` has size </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([],</span> <span class="n">transform</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">apply_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;With a dict supplied to apply_transform, should return a dict or a list of dicts.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CSVDataset"><a class="viewcode-back" href="../../../data.html#monai.data.CSVDataset">[docs]</a><span class="k">class</span> <span class="nc">CSVDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dataset to load data from CSV files and generate a list of dictionaries,</span>
<span class="sd">    every dictionay maps to a row of the CSV file, and the keys of dictionary</span>
<span class="sd">    map to the column names of the CSV file.</span>

<span class="sd">    It can load multiple CSV files and join the tables with addtional `kwargs` arg.</span>
<span class="sd">    Support to only load specific rows and columns.</span>
<span class="sd">    And it can also group several loaded columns to generate a new column, for example,</span>
<span class="sd">    set `col_groups={&quot;meta&quot;: [&quot;meta_0&quot;, &quot;meta_1&quot;, &quot;meta_2&quot;]}`, output can be::</span>

<span class="sd">        [</span>
<span class="sd">            {&quot;image&quot;: &quot;./image0.nii&quot;, &quot;meta_0&quot;: 11, &quot;meta_1&quot;: 12, &quot;meta_2&quot;: 13, &quot;meta&quot;: [11, 12, 13]},</span>
<span class="sd">            {&quot;image&quot;: &quot;./image1.nii&quot;, &quot;meta_0&quot;: 21, &quot;meta_1&quot;: 22, &quot;meta_2&quot;: 23, &quot;meta&quot;: [21, 22, 23]},</span>
<span class="sd">        ]</span>

<span class="sd">    Args:</span>
<span class="sd">        filename: the filename of expected CSV file to load. if providing a list</span>
<span class="sd">            of filenames, it will load all the files and join tables.</span>
<span class="sd">        row_indices: indices of the expected rows to load. it should be a list,</span>
<span class="sd">            every item can be a int number or a range `[start, end)` for the indices.</span>
<span class="sd">            for example: `row_indices=[[0, 100], 200, 201, 202, 300]`. if None,</span>
<span class="sd">            load all the rows in the file.</span>
<span class="sd">        col_names: names of the expected columns to load. if None, load all the columns.</span>
<span class="sd">        col_types: `type` and `default value` to convert the loaded columns, if None, use original data.</span>
<span class="sd">            it should be a dictionary, every item maps to an expected column, the `key` is the column</span>
<span class="sd">            name and the `value` is None or a dictionary to define the default value and data type.</span>
<span class="sd">            the supported keys in dictionary are: [&quot;type&quot;, &quot;default&quot;]. for example::</span>

<span class="sd">                col_types = {</span>
<span class="sd">                    &quot;subject_id&quot;: {&quot;type&quot;: str},</span>
<span class="sd">                    &quot;label&quot;: {&quot;type&quot;: int, &quot;default&quot;: 0},</span>
<span class="sd">                    &quot;ehr_0&quot;: {&quot;type&quot;: float, &quot;default&quot;: 0.0},</span>
<span class="sd">                    &quot;ehr_1&quot;: {&quot;type&quot;: float, &quot;default&quot;: 0.0},</span>
<span class="sd">                    &quot;image&quot;: {&quot;type&quot;: str, &quot;default&quot;: None},</span>
<span class="sd">                }</span>

<span class="sd">        col_groups: args to group the loaded columns to generate a new column,</span>
<span class="sd">            it should be a dictionary, every item maps to a group, the `key` will</span>
<span class="sd">            be the new column name, the `value` is the names of columns to combine. for example:</span>
<span class="sd">            `col_groups={&quot;ehr&quot;: [f&quot;ehr_{i}&quot; for i in range(10)], &quot;meta&quot;: [&quot;meta_1&quot;, &quot;meta_2&quot;]}`</span>
<span class="sd">        transform: transform to apply on the loaded items of a dictionary data.</span>
<span class="sd">        kwargs: additional arguments for `pandas.merge()` API to join tables.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">row_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col_groups</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">convert_tables_to_dicts</span><span class="p">(</span>
            <span class="n">dfs</span><span class="o">=</span><span class="n">dfs</span><span class="p">,</span>
            <span class="n">row_indices</span><span class="o">=</span><span class="n">row_indices</span><span class="p">,</span>
            <span class="n">col_names</span><span class="o">=</span><span class="n">col_names</span><span class="p">,</span>
            <span class="n">col_types</span><span class="o">=</span><span class="n">col_types</span><span class="p">,</span>
            <span class="n">col_groups</span><span class="o">=</span><span class="n">col_groups</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2021 MONAI Consortium.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>