
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>monai.data.image_reader &#8212; MONAI 0.6.0 Documentation</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/MONAI-logo-color.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../whatsnew.html">
  Whatâ€™s New
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../highlights.html">
  Modules Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../installation.html">
  Installation Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../contrib.html">
  Development
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/Project-MONAI/tutorials">Tutorials<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/project-monai/monai" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/projectmonai" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for monai.data.image_reader</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2020 - 2021 MONAI Consortium</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">torch.utils.data._utils.collate</span> <span class="kn">import</span> <span class="n">np_str_obj_array_pattern</span>

<span class="kn">from</span> <span class="nn">monai.config</span> <span class="kn">import</span> <span class="n">DtypeLike</span><span class="p">,</span> <span class="n">KeysCollection</span>
<span class="kn">from</span> <span class="nn">monai.data.utils</span> <span class="kn">import</span> <span class="n">correct_nifti_header_if_necessary</span>
<span class="kn">from</span> <span class="nn">monai.transforms.utility.array</span> <span class="kn">import</span> <span class="n">EnsureChannelFirst</span>
<span class="kn">from</span> <span class="nn">monai.utils</span> <span class="kn">import</span> <span class="n">ensure_tuple</span><span class="p">,</span> <span class="n">ensure_tuple_rep</span><span class="p">,</span> <span class="n">optional_import</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">is_supported_format</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cucim</span>
    <span class="kn">import</span> <span class="nn">itk</span>  <span class="c1"># type: ignore</span>
    <span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
    <span class="kn">import</span> <span class="nn">openslide</span>
    <span class="kn">from</span> <span class="nn">itk</span> <span class="kn">import</span> <span class="n">Image</span>  <span class="c1"># type: ignore</span>
    <span class="kn">from</span> <span class="nn">nibabel.nifti1</span> <span class="kn">import</span> <span class="n">Nifti1Image</span>
    <span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span> <span class="k">as</span> <span class="n">PILImage</span>

    <span class="n">has_itk</span> <span class="o">=</span> <span class="n">has_nib</span> <span class="o">=</span> <span class="n">has_pil</span> <span class="o">=</span> <span class="n">has_cim</span> <span class="o">=</span> <span class="n">has_osl</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">itk</span><span class="p">,</span> <span class="n">has_itk</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;itk&quot;</span><span class="p">,</span> <span class="n">allow_namespace_pkg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Image</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;itk&quot;</span><span class="p">,</span> <span class="n">allow_namespace_pkg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Image&quot;</span><span class="p">)</span>
    <span class="n">nib</span><span class="p">,</span> <span class="n">has_nib</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;nibabel&quot;</span><span class="p">)</span>
    <span class="n">Nifti1Image</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;nibabel.nifti1&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Nifti1Image&quot;</span><span class="p">)</span>
    <span class="n">PILImage</span><span class="p">,</span> <span class="n">has_pil</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;PIL.Image&quot;</span><span class="p">)</span>
    <span class="n">cucim</span><span class="p">,</span> <span class="n">has_cim</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;cucim&quot;</span><span class="p">)</span>
    <span class="n">openslide</span><span class="p">,</span> <span class="n">has_osl</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s2">&quot;openslide&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ImageReader&quot;</span><span class="p">,</span> <span class="s2">&quot;ITKReader&quot;</span><span class="p">,</span> <span class="s2">&quot;NibabelReader&quot;</span><span class="p">,</span> <span class="s2">&quot;NumpyReader&quot;</span><span class="p">,</span> <span class="s2">&quot;PILReader&quot;</span><span class="p">,</span> <span class="s2">&quot;WSIReader&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="ImageReader"><a class="viewcode-back" href="../../../data.html#monai.data.ImageReader">[docs]</a><span class="k">class</span> <span class="nc">ImageReader</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class to define interface APIs to load image files.</span>
<span class="sd">    users need to call `read` to load image and then use `get_data`</span>
<span class="sd">    to get the image data and properties from meta data.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ImageReader.verify_suffix"><a class="viewcode-back" href="../../../data.html#monai.data.ImageReader.verify_suffix">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">verify_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify whether the specified file or files format is supported by current reader.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: file name or a list of file names to read.</span>
<span class="sd">                if a list of files, verify all the suffixes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subclass </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must implement this method.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageReader.read"><a class="viewcode-back" href="../../../data.html#monai.data.ImageReader.read">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read image data from specified file or files.</span>
<span class="sd">        Note that it returns the raw data, so different readers return different image data type.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: file name or a list of file names to read.</span>
<span class="sd">            kwargs: additional args for actual `read` API of 3rd party libs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subclass </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must implement this method.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageReader.get_data"><a class="viewcode-back" href="../../../data.html#monai.data.ImageReader.get_data">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract data array and meta data from loaded image and return them.</span>
<span class="sd">        This function must return 2 objects, first is numpy array of image data, second is dict of meta data.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: an image object loaded from a image file or a list of image objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subclass </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must implement this method.&quot;</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_copy_compatible_dict</span><span class="p">(</span><span class="n">from_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">to_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;to_dict must be a Dict, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">to_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">to_dict</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">from_dict</span><span class="p">:</span>
            <span class="n">datum</span> <span class="o">=</span> <span class="n">from_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np_str_obj_array_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">datum</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">to_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">datum</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_key</span><span class="p">,</span> <span class="n">shape_key</span> <span class="o">=</span> <span class="s2">&quot;affine&quot;</span><span class="p">,</span> <span class="s2">&quot;spatial_shape&quot;</span>
        <span class="k">if</span> <span class="n">affine_key</span> <span class="ow">in</span> <span class="n">from_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">from_dict</span><span class="p">[</span><span class="n">affine_key</span><span class="p">],</span> <span class="n">to_dict</span><span class="p">[</span><span class="n">affine_key</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;affine matrix of all images should be the same for channel-wise concatenation. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">from_dict</span><span class="p">[</span><span class="n">affine_key</span><span class="p">]</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">to_dict</span><span class="p">[</span><span class="n">affine_key</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">shape_key</span> <span class="ow">in</span> <span class="n">from_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">from_dict</span><span class="p">[</span><span class="n">shape_key</span><span class="p">],</span> <span class="n">to_dict</span><span class="p">[</span><span class="n">shape_key</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;spatial_shape of all images should be the same for channel-wise concatenation. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">from_dict</span><span class="p">[</span><span class="n">shape_key</span><span class="p">]</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">to_dict</span><span class="p">[</span><span class="n">shape_key</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>


<span class="k">def</span> <span class="nf">_stack_images</span><span class="p">(</span><span class="n">image_list</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">meta_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">meta_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;original_channel_dim&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;no_channel&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;can not read a list of images which already have channel dimension.&quot;</span><span class="p">)</span>
        <span class="n">meta_dict</span><span class="p">[</span><span class="s2">&quot;original_channel_dim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">img_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">image_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img_array</span> <span class="o">=</span> <span class="n">image_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">img_array</span>


<div class="viewcode-block" id="ITKReader"><a class="viewcode-back" href="../../../data.html#monai.data.ITKReader">[docs]</a><span class="k">class</span> <span class="nc">ITKReader</span><span class="p">(</span><span class="n">ImageReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load medical images based on ITK library.</span>
<span class="sd">    All the supported image formats can be found:</span>
<span class="sd">    https://github.com/InsightSoftwareConsortium/ITK/tree/master/Modules/IO</span>
<span class="sd">    The loaded data array will be in C order, for example, a 3D image NumPy</span>
<span class="sd">    array index order will be `CDWH`.</span>

<span class="sd">    Args:</span>
<span class="sd">        kwargs: additional args for `itk.imread` API. more details about available args:</span>
<span class="sd">            https://github.com/InsightSoftwareConsortium/ITK/blob/master/Wrapping/Generators/Python/itkExtras.py</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="n">has_itk</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">itk</span><span class="o">.</span><span class="n">Version</span><span class="o">.</span><span class="n">GetITKMajorVersion</span><span class="p">())</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">itk</span><span class="o">.</span><span class="n">Version</span><span class="o">.</span><span class="n">GetITKMinorVersion</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># warning the ITK LazyLoading mechanism was not threadsafe until version 5.2.0,</span>
            <span class="c1"># requesting access to the itk.imread function triggers the lazy loading of the relevant itk modules</span>
            <span class="c1"># before the parallel use of the function.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">itk</span><span class="o">.</span><span class="n">imread</span>

<div class="viewcode-block" id="ITKReader.verify_suffix"><a class="viewcode-back" href="../../../data.html#monai.data.ITKReader.verify_suffix">[docs]</a>    <span class="k">def</span> <span class="nf">verify_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify whether the specified file or files format is supported by ITK reader.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: file name or a list of file names to read.</span>
<span class="sd">                if a list of files, verify all the suffixes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">has_itk</span></div>

<div class="viewcode-block" id="ITKReader.read"><a class="viewcode-back" href="../../../data.html#monai.data.ITKReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read image data from specified file or files.</span>
<span class="sd">        Note that the returned object is ITK image object or list of ITK image objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: file name or a list of file names to read,</span>
<span class="sd">            kwargs: additional args for `itk.imread` API, will override `self.kwargs` for existing keys.</span>
<span class="sd">                More details about available args:</span>
<span class="sd">                https://github.com/InsightSoftwareConsortium/ITK/blob/master/Wrapping/Generators/Python/itkExtras.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Image</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">filenames</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">kwargs_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="c1"># read DICOM series of 1 image in a folder, refer to: https://github.com/RSIP-Vision/medio</span>
                <span class="n">names_generator</span> <span class="o">=</span> <span class="n">itk</span><span class="o">.</span><span class="n">GDCMSeriesFileNames</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>
                <span class="n">names_generator</span><span class="o">.</span><span class="n">SetUseSeriesDetails</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">names_generator</span><span class="o">.</span><span class="n">AddSeriesRestriction</span><span class="p">(</span><span class="s2">&quot;0008|0021&quot;</span><span class="p">)</span>  <span class="c1"># Series Date</span>
                <span class="n">names_generator</span><span class="o">.</span><span class="n">SetDirectory</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">series_uid</span> <span class="o">=</span> <span class="n">names_generator</span><span class="o">.</span><span class="n">GetSeriesUIDs</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">series_uid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no DICOMs in: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">series_uid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the directory: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> contains more than one DICOM series.&quot;</span><span class="p">)</span>

                <span class="n">series_identifier</span> <span class="o">=</span> <span class="n">series_uid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">names_generator</span><span class="o">.</span><span class="n">GetFileNames</span><span class="p">(</span><span class="n">series_identifier</span><span class="p">)</span>

            <span class="n">img_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">itk</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">img_</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">img_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="ITKReader.get_data"><a class="viewcode-back" href="../../../data.html#monai.data.ITKReader.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract data array and meta data from loaded image and return them.</span>
<span class="sd">        This function returns 2 objects, first is numpy array of image data, second is dict of meta data.</span>
<span class="sd">        It constructs `affine`, `original_affine`, and `spatial_shape` and stores in meta dict.</span>
<span class="sd">        If loading a list of files, stack them together and add a new dimension as first dimension,</span>
<span class="sd">        and use the meta data of the first image to represent the stacked result.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a ITK image object loaded from a image file or a list of ITK image objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">compatible_meta</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
            <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_meta_dict</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;original_affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_affine</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;original_affine&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spatial_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">img_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;original_channel_dim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;no_channel&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">_copy_compatible_dict</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_stack_images</span><span class="p">(</span><span class="n">img_array</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">),</span> <span class="n">compatible_meta</span></div>

    <span class="k">def</span> <span class="nf">_get_meta_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the meta data of the image and convert to dict type.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a ITK image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_meta_dict</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">GetMetaDataDictionary</span><span class="p">()</span>
        <span class="n">meta_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">img_meta_dict</span><span class="o">.</span><span class="n">GetKeys</span><span class="p">():</span>
            <span class="c1"># ignore deprecated, legacy members that cause issues</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ITK_original_&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;NRRD_measurement frame&quot;</span>
                <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">itk</span><span class="o">.</span><span class="n">Version</span><span class="o">.</span><span class="n">GetITKMajorVersion</span><span class="p">())</span> <span class="o">==</span> <span class="mi">5</span>
                <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">itk</span><span class="o">.</span><span class="n">Version</span><span class="o">.</span><span class="n">GetITKMinorVersion</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">2</span>
            <span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Ignoring &#39;measurement frame&#39; field. &quot;</span>
                    <span class="s2">&quot;Correct reading of NRRD05 files requires ITK &gt;= 5.2: `pip install --upgrade --pre itk`&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">meta_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_meta_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">meta_dict</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">GetOrigin</span><span class="p">())</span>
        <span class="n">meta_dict</span><span class="p">[</span><span class="s2">&quot;spacing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">GetSpacing</span><span class="p">())</span>
        <span class="n">meta_dict</span><span class="p">[</span><span class="s2">&quot;direction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">itk</span><span class="o">.</span><span class="n">array_from_matrix</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">GetDirection</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">meta_dict</span>

    <span class="k">def</span> <span class="nf">_get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get or construct the affine matrix of the image, it can be used to correct</span>
<span class="sd">        spacing, orientation or execute spatial transforms.</span>
<span class="sd">        Construct Affine matrix based on direction, spacing, origin information.</span>
<span class="sd">        Refer to: https://github.com/RSIP-Vision/medio</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a ITK image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">itk</span><span class="o">.</span><span class="n">array_from_matrix</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">GetDirection</span><span class="p">())</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">GetSpacing</span><span class="p">())</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">GetOrigin</span><span class="p">())</span>

        <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
        <span class="n">affine</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">direction</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">affine</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))]</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
        <span class="n">affine</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="k">return</span> <span class="n">affine</span>

    <span class="k">def</span> <span class="nf">_get_spatial_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spatial shape of image data, it doesn&#39;t contain the channel dim.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a ITK image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the img data should have no channel dim or the last dim is channel</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itk</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
        <span class="n">shape</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_array_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the raw array data of the image, converted to Numpy array.</span>

<span class="sd">        Following PyTorch conventions, the returned array data has contiguous channels,</span>
<span class="sd">        e.g. for an RGB image, all red channel image pixels are contiguous in memory.</span>
<span class="sd">        The first axis of the returned array is the channel axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a ITK image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">GetNumberOfComponentsPerPixel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">itk</span><span class="o">.</span><span class="n">array_view_from_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">keep_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># The memory layout of itk.Image has all pixel&#39;s channels adjacent</span>
        <span class="c1"># in memory, i.e. R1G1B1R2G2B2R3G3B3. For PyTorch/MONAI, we need</span>
        <span class="c1"># channels to be contiguous, i.e. R1R2R3G1G2G3B1B2B3.</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">itk</span><span class="o">.</span><span class="n">array_view_from_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">keep_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">dest</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">source</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span></div>


<div class="viewcode-block" id="NibabelReader"><a class="viewcode-back" href="../../../data.html#monai.data.NibabelReader">[docs]</a><span class="k">class</span> <span class="nc">NibabelReader</span><span class="p">(</span><span class="n">ImageReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load NIfTI format images based on Nibabel library.</span>

<span class="sd">    Args:</span>
<span class="sd">        as_closest_canonical: if True, load the image as closest to canonical axis format.</span>
<span class="sd">        kwargs: additional args for `nibabel.load` API. more details about available args:</span>
<span class="sd">            https://github.com/nipy/nibabel/blob/master/nibabel/loadsave.py</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_closest_canonical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_closest_canonical</span> <span class="o">=</span> <span class="n">as_closest_canonical</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="NibabelReader.verify_suffix"><a class="viewcode-back" href="../../../data.html#monai.data.NibabelReader.verify_suffix">[docs]</a>    <span class="k">def</span> <span class="nf">verify_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify whether the specified file or files format is supported by Nibabel reader.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: file name or a list of file names to read.</span>
<span class="sd">                if a list of files, verify all the suffixes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">suffixes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;nii&quot;</span><span class="p">,</span> <span class="s2">&quot;nii.gz&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">has_nib</span> <span class="ow">and</span> <span class="n">is_supported_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">)</span></div>

<div class="viewcode-block" id="NibabelReader.read"><a class="viewcode-back" href="../../../data.html#monai.data.NibabelReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read image data from specified file or files.</span>
<span class="sd">        Note that the returned object is Nibabel image object or list of Nibabel image objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: file name or a list of file names to read.</span>
<span class="sd">            kwargs: additional args for `nibabel.load` API, will override `self.kwargs` for existing keys.</span>
<span class="sd">                More details about available args:</span>
<span class="sd">                https://github.com/nipy/nibabel/blob/master/nibabel/loadsave.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Nifti1Image</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">filenames</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">kwargs_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">correct_nifti_header_if_necessary</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="n">img_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img_</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">img_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="NibabelReader.get_data"><a class="viewcode-back" href="../../../data.html#monai.data.NibabelReader.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract data array and meta data from loaded image and return them.</span>
<span class="sd">        This function returns 2 objects, first is numpy array of image data, second is dict of meta data.</span>
<span class="sd">        It constructs `affine`, `original_affine`, and `spatial_shape` and stores in meta dict.</span>
<span class="sd">        If loading a list of files, stack them together and add a new dimension as first dimension,</span>
<span class="sd">        and use the meta data of the first image to represent the stacked result.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a Nibabel image object loaded from a image file or a list of Nibabel image objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">compatible_meta</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
            <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_meta_dict</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_affine</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;original_affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_affine</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;as_closest_canonical&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_closest_canonical</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_closest_canonical</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">as_closest_canonical</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">header</span><span class="p">[</span><span class="s2">&quot;affine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_affine</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spatial_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">img_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;original_channel_dim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;no_channel&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">_copy_compatible_dict</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_stack_images</span><span class="p">(</span><span class="n">img_array</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">),</span> <span class="n">compatible_meta</span></div>

    <span class="k">def</span> <span class="nf">_get_meta_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the all the meta data of the image and convert to dict type.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a Nibabel image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># swap to little endian as PyTorch doesn&#39;t support big endian</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">as_byteswapped</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the affine matrix of the image, it can be used to correct</span>
<span class="sd">        spacing, orientation or execute spatial transforms.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a Nibabel image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_spatial_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spatial shape of image data, it doesn&#39;t contain the channel dim.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a Nibabel image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># swap to little endian as PyTorch doesn&#39;t support big endian</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">as_byteswapped</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;dim&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spatial_rank</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># the img data should have no channel dim or the last dim is channel</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;dim&quot;</span><span class="p">][</span><span class="mi">1</span> <span class="p">:</span> <span class="n">spatial_rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_array_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the raw array data of the image, converted to Numpy array.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a Nibabel image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">img</span><span class="o">.</span><span class="n">uncache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">_array</span></div>


<div class="viewcode-block" id="NumpyReader"><a class="viewcode-back" href="../../../data.html#monai.data.NumpyReader">[docs]</a><span class="k">class</span> <span class="nc">NumpyReader</span><span class="p">(</span><span class="n">ImageReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load NPY or NPZ format data based on Numpy library, they can be arrays or pickled objects.</span>
<span class="sd">    A typical usage is to load the `mask` data for classification task.</span>
<span class="sd">    It can load part of the npz file with specified `npz_keys`.</span>

<span class="sd">    Args:</span>
<span class="sd">        npz_keys: if loading npz file, only load the specified keys, if None, load all the items.</span>
<span class="sd">            stack the loaded items together to construct a new first dimension.</span>
<span class="sd">        kwargs: additional args for `numpy.load` API except `allow_pickle`. more details about available args:</span>
<span class="sd">            https://numpy.org/doc/stable/reference/generated/numpy.load.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npz_keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">KeysCollection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">npz_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">npz_keys</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">npz_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npz_keys</span> <span class="o">=</span> <span class="n">npz_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="NumpyReader.verify_suffix"><a class="viewcode-back" href="../../../data.html#monai.data.NumpyReader.verify_suffix">[docs]</a>    <span class="k">def</span> <span class="nf">verify_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify whether the specified file or files format is supported by Numpy reader.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: file name or a list of file names to read.</span>
<span class="sd">                if a list of files, verify all the suffixes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">suffixes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;npz&quot;</span><span class="p">,</span> <span class="s2">&quot;npy&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">is_supported_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyReader.read"><a class="viewcode-back" href="../../../data.html#monai.data.NumpyReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read image data from specified file or files.</span>
<span class="sd">        Note that the returned object is Numpy array or list of Numpy arrays.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: file name or a list of file names to read.</span>
<span class="sd">            kwargs: additional args for `numpy.load` API except `allow_pickle`, will override `self.kwargs` for existing keys.</span>
<span class="sd">                More details about available args:</span>
<span class="sd">                https://numpy.org/doc/stable/reference/generated/numpy.load.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Nifti1Image</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">filenames</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">kwargs_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.npz&quot;</span><span class="p">):</span>
                <span class="c1"># load expected items from NPZ file</span>
                <span class="n">npz_keys</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;arr_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">))]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npz_keys</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">npz_keys</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">npz_keys</span><span class="p">:</span>
                    <span class="n">img_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">img_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="NumpyReader.get_data"><a class="viewcode-back" href="../../../data.html#monai.data.NumpyReader.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract data array and meta data from loaded data and return them.</span>
<span class="sd">        This function returns 2 objects, first is numpy array of image data, second is dict of meta data.</span>
<span class="sd">        It constructs `spatial_shape=data.shape` and stores in meta dict if the data is numpy array.</span>
<span class="sd">        If loading a list of files, stack them together and add a new dimension as first dimension,</span>
<span class="sd">        and use the meta data of the first image to represent the stacked result.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a Numpy array loaded from a file or a list of Numpy arrays.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">compatible_meta</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
            <span class="n">header</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># can not detect the channel dim of numpy array, use all the dims as spatial_shape</span>
                <span class="n">header</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">img_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">_copy_compatible_dict</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_stack_images</span><span class="p">(</span><span class="n">img_array</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">),</span> <span class="n">compatible_meta</span></div></div>


<div class="viewcode-block" id="PILReader"><a class="viewcode-back" href="../../../data.html#monai.data.PILReader">[docs]</a><span class="k">class</span> <span class="nc">PILReader</span><span class="p">(</span><span class="n">ImageReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load common 2D image format (supports PNG, JPG, BMP) file or files from provided path.</span>

<span class="sd">    Args:</span>
<span class="sd">        converter: additional function to convert the image data after `read()`.</span>
<span class="sd">            for example, use `converter=lambda image: image.convert(&quot;LA&quot;)` to convert image format.</span>
<span class="sd">        kwargs: additional args for `Image.open` API in `read()`, mode details about available args:</span>
<span class="sd">            https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.open</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">converter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span> <span class="o">=</span> <span class="n">converter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="PILReader.verify_suffix"><a class="viewcode-back" href="../../../data.html#monai.data.PILReader.verify_suffix">[docs]</a>    <span class="k">def</span> <span class="nf">verify_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify whether the specified file or files format is supported by PIL reader.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: file name or a list of file names to read.</span>
<span class="sd">                if a list of files, verify all the suffixes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">suffixes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="s2">&quot;jpg&quot;</span><span class="p">,</span> <span class="s2">&quot;jpeg&quot;</span><span class="p">,</span> <span class="s2">&quot;bmp&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">has_pil</span> <span class="ow">and</span> <span class="n">is_supported_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">)</span></div>

<div class="viewcode-block" id="PILReader.read"><a class="viewcode-back" href="../../../data.html#monai.data.PILReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read image data from specified file or files.</span>
<span class="sd">        Note that the returned object is PIL image or list of PIL image.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: file name or a list of file names to read.</span>
<span class="sd">            kwargs: additional args for `Image.open` API in `read()`, will override `self.kwargs` for existing keys.</span>
<span class="sd">                Mode details about available args:</span>
<span class="sd">                https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.open</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PILImage</span><span class="o">.</span><span class="n">Image</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">filenames</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">kwargs_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">PILImage</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="p">):</span>
                <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="n">img_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">img_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="PILReader.get_data"><a class="viewcode-back" href="../../../data.html#monai.data.PILReader.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract data array and meta data from loaded data and return them.</span>
<span class="sd">        This function returns 2 objects, first is numpy array of image data, second is dict of meta data.</span>
<span class="sd">        It constructs `spatial_shape` and stores in meta dict.</span>
<span class="sd">        If loading a list of files, stack them together and add a new dimension as first dimension,</span>
<span class="sd">        and use the meta data of the first image to represent the stacked result.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a PIL Image object loaded from a file or a list of PIL Image objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">compatible_meta</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
            <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_meta_dict</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spatial_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">img_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">header</span><span class="p">[</span><span class="s2">&quot;original_channel_dim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;no_channel&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">_copy_compatible_dict</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_stack_images</span><span class="p">(</span><span class="n">img_array</span><span class="p">,</span> <span class="n">compatible_meta</span><span class="p">),</span> <span class="n">compatible_meta</span></div>

    <span class="k">def</span> <span class="nf">_get_meta_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the all the meta data of the image and convert to dict type.</span>
<span class="sd">        Args:</span>
<span class="sd">            img: a PIL Image object loaded from a image file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="n">img</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
            <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">img</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
            <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">img</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
            <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">img</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_get_spatial_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spatial shape of image data, it doesn&#39;t contain the channel dim.</span>
<span class="sd">        Args:</span>
<span class="sd">            img: a PIL Image object loaded from a image file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the img data should have no channel dim or the last dim is channel</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">height</span><span class="p">))</span></div>


<div class="viewcode-block" id="WSIReader"><a class="viewcode-back" href="../../../data.html#monai.data.WSIReader">[docs]</a><span class="k">class</span> <span class="nc">WSIReader</span><span class="p">(</span><span class="n">ImageReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read whole slide imaging and extract patches.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_lib: backend library to load the images, available options: &quot;OpenSlide&quot; or &quot;cuCIM&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_lib</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;OpenSlide&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">=</span> <span class="n">reader_lib</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">==</span> <span class="s2">&quot;openslide&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_osl</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wsi_reader</span> <span class="o">=</span> <span class="n">openslide</span><span class="o">.</span><span class="n">OpenSlide</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">==</span> <span class="s2">&quot;cucim&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_cim</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wsi_reader</span> <span class="o">=</span> <span class="n">cucim</span><span class="o">.</span><span class="n">CuImage</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`reader_lib` should be either &quot;cuCIM&quot; or &quot;OpenSlide&quot;&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="WSIReader.verify_suffix"><a class="viewcode-back" href="../../../data.html#monai.data.WSIReader.verify_suffix">[docs]</a>    <span class="k">def</span> <span class="nf">verify_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify whether the specified file or files format is supported by WSI reader.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: file name or a list of file names to read.</span>
<span class="sd">                if a list of files, verify all the suffixes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_supported_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;tif&quot;</span><span class="p">,</span> <span class="s2">&quot;tiff&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="WSIReader.read"><a class="viewcode-back" href="../../../data.html#monai.data.WSIReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read image data from specified file or files.</span>
<span class="sd">        Note that the returned object is CuImage or list of CuImage objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: file name or a list of file names to read.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">==</span> <span class="s2">&quot;openslide&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">has_osl</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;No module named &#39;openslide&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">==</span> <span class="s2">&quot;cucim&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">has_cim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;No module named &#39;cucim&#39;&quot;</span><span class="p">)</span>

        <span class="n">img_</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">filenames</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensure_tuple</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wsi_reader</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">==</span> <span class="s2">&quot;openslide&quot;</span><span class="p">:</span>
                <span class="n">img</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">img_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">img_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="WSIReader.get_data"><a class="viewcode-back" href="../../../data.html#monai.data.WSIReader.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
        <span class="n">grid_shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">patch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract regions as numpy array from WSI image and return them.</span>

<span class="sd">        Args:</span>
<span class="sd">            img: a WSIReader image object loaded from a file, or list of CuImage objects</span>
<span class="sd">            location: (x_min, y_min) tuple giving the top left pixel in the level 0 reference frame,</span>
<span class="sd">            or list of tuples (default=(0, 0))</span>
<span class="sd">            size: (height, width) tuple giving the region size, or list of tuples (default to full image size)</span>
<span class="sd">            This is the size of image at the given level (`level`)</span>
<span class="sd">            level: the level number, or list of level numbers (default=0)</span>
<span class="sd">            dtype: the data type of output image</span>
<span class="sd">            grid_shape: (row, columns) tuple define a grid to extract patches on that</span>
<span class="sd">            patch_size: (height, width) the size of extracted patches at the given level</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">==</span> <span class="s2">&quot;openslide&quot;</span> <span class="ow">and</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># the maximum size is set to WxH</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_region</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">metadata</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;original_channel_dim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">EnsureChannelFirst</span><span class="p">()(</span><span class="n">region</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">patch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="n">region</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tuple_patch_size</span> <span class="o">=</span> <span class="n">ensure_tuple_rep</span><span class="p">(</span><span class="n">patch_size</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_patches</span><span class="p">(</span>
                <span class="n">region</span><span class="p">,</span>
                <span class="n">patch_size</span><span class="o">=</span><span class="n">tuple_patch_size</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="n">grid_shape</span><span class="o">=</span><span class="n">grid_shape</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">patches</span><span class="p">,</span> <span class="n">metadata</span></div>

    <span class="k">def</span> <span class="nf">_extract_region</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img_obj</span><span class="p">,</span>
        <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># reverse the order of dimensions for size and location to be compatible with image shape</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">location</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">read_region</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">read_region</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_rgb_array</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">region</span>

<div class="viewcode-block" id="WSIReader.convert_to_rgb_array"><a class="viewcode-back" href="../../../data.html#monai.data.WSIReader.convert_to_rgb_array">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_rgb_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raw_region</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert to RGB mode and numpy array&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader_lib</span> <span class="o">==</span> <span class="s2">&quot;openslide&quot;</span><span class="p">:</span>
            <span class="c1"># convert to RGB</span>
            <span class="n">raw_region</span> <span class="o">=</span> <span class="n">raw_region</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;RGB&quot;</span><span class="p">)</span>
            <span class="c1"># convert to numpy</span>
            <span class="n">raw_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">raw_region</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_region</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)</span>
            <span class="c1"># convert to numpy</span>
            <span class="n">raw_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">raw_region</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="c1"># remove alpha channel if exist (RGBA)</span>
            <span class="k">if</span> <span class="n">num_channels</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">raw_region</span> <span class="o">=</span> <span class="n">raw_region</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">raw_region</span></div>

    <span class="k">def</span> <span class="nf">_extract_patches</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">grid_shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">patch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">patch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">grid_shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">region</span>

        <span class="n">n_patches</span> <span class="o">=</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">region_size</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">patch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">patch_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">region_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">region_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># split the region into patches on the grid and center crop them to patch size</span>
        <span class="n">flat_patch_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_patches</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">start_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">region_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="n">grid_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">patch_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">y_start</span> <span class="ow">in</span> <span class="n">start_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">x_start</span> <span class="ow">in</span> <span class="n">start_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">x_end</span> <span class="o">=</span> <span class="n">x_start</span> <span class="o">+</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y_end</span> <span class="o">=</span> <span class="n">y_start</span> <span class="o">+</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">flat_patch_grid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span><span class="p">[:,</span> <span class="n">x_start</span><span class="p">:</span><span class="n">x_end</span><span class="p">,</span> <span class="n">y_start</span><span class="p">:</span><span class="n">y_end</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">flat_patch_grid</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2021 MONAI Consortium.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>